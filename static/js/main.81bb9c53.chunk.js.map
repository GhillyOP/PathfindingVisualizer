{"version":3,"sources":["assets/draw.gif","assets/select-algo.gif","path-finding-visualizer/node-states.js","path-finding-visualizer/node.jsx","path-finding-visualizer/grid-utilities.js","path-finding-visualizer/grid.jsx","path-finding-visualizer/demo-node.jsx","path-finding-visualizer/help.jsx","algorithms/binary-tree.js","algorithms/random.js","data-structures/min-heap.js","algorithms/a-star.js","algorithms/dijkstra.js","path-finding-visualizer/path-finding-visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","NodeStates","VISITED","UNVISITED","WALL","SHORTESTPATH","Node","props","state","nodeState","isStart","isEnd","nextProps","hasNodeStateChanged","this","isStartChanged","isEndChanged","row","col","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","id","onDragStart","preventDragHandler","className","Component","createGrid","rowCount","colCount","startNodeIndex","endNodeIndex","grid","i","j","push","createNode","distance","Infinity","gCost","hCost","previousState","closed","previousNode","setNodeInGrid","node","newNode","previousNodeState","clearVisitedNodes","length","document","getElementById","clearWallNodes","getClassFromState","Grid","handleMouseDown","isVisualizing","nextNodeState","gridData","beginDragStart","setState","isMouseDown","beginDragEnd","tempGrid","handleMouseLeave","handleMouseEnter","newGrid","newStartNode","firstElementChild","setStartNode","newEndNode","setEndNode","e","preventDefault","updateGrid","updateStartEndIndex","handleMouseUp","map","rowI","key","nodeI","isWall","shouldUpdate","renderGrid","DemoNode","Help","handleBackgroundClick","stopPropagation","toggleHelpPanel","handlePanelClick","isVisible","prevProps","onClick","src","selectAlgo","width","height","alt","draw","executeBinaryTree","startNode","endNode","neighbours","NodeState","rand","Math","floor","random","filter","neighbour","getAllNodesInGrid","executeRandom","MinHeap","heap","Map","heapIndex","get","set","index","element","swap","smallest","delete","pop","sinkDown","left","right","index1","index2","temp","executeAStar","t0","performance","now","open","insert","size","closestNode","remove","t1","console","log","getAvailableNeighbours","includes","getNewGCost","undefined","getNodeAt","getManhattanHCost","changeDistance","currentNode","destNode","y","abs","firstDirection","secondDirection","executeDijkstra","unvisitedNodes","nodes","getAllNodesHeap","visitedNodesInOrder","getAvailableNeighboursHeap","newDistance","setPreviousNode","topNeighbour","rightNeighbour","bottomNeighbour","leftNeighbour","PathFindindVisualizer","visualize","shortestPath","shortestPathTimeout","setTimeout","visualizeShortestPath","visitedAnimationTimeout","selectAlgorithm","selectedAlgo","selectedAlgoName","selectedMazeAlgo","selectedMazeAlgoName","isHelpVisible","isMaze","updateWindowDimensions","bind","updateArrayLength","window","addEventListener","removeEventListener","reset","innerWidth","innerHeight","nodeSize","documentElement","style","setProperty","Array","from","forEach","clearTimeout","replaceGrid","shortestPathNodes","reverse","getShortestPath","toWaitBeforeEnded","maze","DropdownButton","title","Dropdown","Item","as","executePathfinding","visualizeMaze","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.81bb9c53.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/draw.baeb09ed.gif\";","module.exports = __webpack_public_path__ + \"static/media/select-algo.4c19d5ce.gif\";","const NodeStates = {\r\n    VISITED: \"visited\",\r\n    UNVISITED: \"unvisited\",\r\n    WALL: \"wall\",\r\n    SHORTESTPATH: 'shortestPath'\r\n  };\r\n\r\nexport default NodeStates;\r\n","import React, { Component } from \"react\";\r\nimport \"./grid.css\";\r\nimport NodeStates from \"./node-states\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodeState: NodeStates.UNVISITED,\r\n      isStart: false,\r\n      isEnd: false\r\n    };\r\n  }\r\n\r\n  /** Make sure not all nodes update every time the grid renders */\r\n  shouldComponentUpdate(nextProps) {\r\n    const hasNodeStateChanged = this.props.nodeState !== nextProps.nodeState;\r\n    const isStartChanged = this.props.isStart !== nextProps.isStart;\r\n    const isEndChanged = this.props.isEnd !== nextProps.isEnd;\r\n\r\n    return hasNodeStateChanged || isStartChanged || isEndChanged;\r\n  }\r\n\r\n  /** Change State based on property nodeState */\r\n  static getDerivedStateFromProps(nextProps) {\r\n    return {\r\n      nodeState: nextProps.nodeState,\r\n      isStart: nextProps.isStart,\r\n      isEnd: nextProps.isEnd\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { row, col, onMouseDown, onMouseEnter, onMouseUp, onMouseLeave } = this.props;\r\n\r\n    if (this.props.isStart) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-start\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.props.isEnd) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-end\"></div>\r\n        </div >\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.WALL) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"WallNode\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.UNVISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`} className=\"\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.VISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"VisitedNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.SHORTESTPATH) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"ShortestPathNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else {\r\n      return <div>no such state</div>;\r\n    }\r\n  }\r\n}\r\n","import NodeStates from \"./node-states\";\r\n\r\nexport const createGrid = (\r\n  rowCount,\r\n  colCount,\r\n  startNodeIndex,\r\n  endNodeIndex\r\n) => {\r\n  let grid = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let row = [];\r\n\r\n    for (let j = 0; j < colCount; j++) {\r\n      row.push(createNode(i, j, startNodeIndex, endNodeIndex));\r\n    }\r\n    grid.push(row);\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const createNode = (row, col, startNodeIndex, endNodeIndex) => {\r\n  let isStart = false;\r\n  let isEnd = false;\r\n\r\n  if (row === startNodeIndex.row && col === startNodeIndex.col) isStart = true;\r\n  else if (row === endNodeIndex.row && col === endNodeIndex.col) isEnd = true;\r\n\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: isStart,\r\n    isEnd: isEnd,\r\n    distance: Infinity,\r\n    gCost: 0,\r\n    hCost: 0,\r\n    previousState: NodeStates.UNVISITED,\r\n    closed: false,\r\n    previousNode: null,\r\n    nodeState: NodeStates.UNVISITED,\r\n  };\r\n};\r\n\r\nexport const setNodeInGrid = (grid, row, col, nodeState) => {\r\n  const node = grid[row][col];\r\n\r\n  const newNode = {\r\n    ...node,\r\n    previousNodeState: nodeState,\r\n    nodeState: nodeState,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nexport const setStartNode = (grid, row, col, startNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newStartNode = {\r\n    ...node,\r\n    previousState: previousState,\r\n    isStart: true,\r\n  };\r\n\r\n  newGrid[row][col] = newStartNode;\r\n  newGrid[startNodeIndex.row][startNodeIndex.col].isStart = false;\r\n  document.getElementById(\r\n    `${startNodeIndex.row}:${startNodeIndex.col}`\r\n  ).className = getClassFromState(grid[startNodeIndex.row][startNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-start\"\r\n\r\n  document.getElementById(`${startNodeIndex.row}:${startNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  startNodeIndex.row = row;\r\n  startNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const setEndNode = (grid, row, col, endNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newEndNode = {\r\n    ...node,\r\n    nodeState: NodeStates.UNVISITED,\r\n    previousState: previousState,\r\n    isEnd: true,\r\n  };\r\n\r\n  newGrid[row][col] = newEndNode;\r\n  newGrid[endNodeIndex.row][endNodeIndex.col].isEnd = false;\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`).className =\r\n    getClassFromState(grid[endNodeIndex.row][endNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-end\"\r\n\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  endNodeIndex.row = row;\r\n  endNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const replaceGrid = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n        grid[i][j].nodeState = NodeStates.WALL;\r\n        grid[i][j].closed = false;\r\n      } else {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const clearVisitedNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        continue;\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const clearWallNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        node.className = \"Node\";\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst getClassFromState = (state) => {\r\n  if (state === NodeStates.UNVISITED) return \"Node\"\r\n  if (state === NodeStates.VISITED) return \"VisitedNodeNoAnim\"\r\n  if (state === NodeStates.WALL) return \"WallNode\"\r\n  if (state === NodeStates.SHORTESTPATH) return \"ShortestPathNodeNoAnim\"\r\n}","import React, { Component } from \"react\";\r\nimport Node from \"./node\";\r\nimport NodeStates from \"./node-states\";\r\nimport \"./grid.css\";\r\nimport {\r\n  setNodeInGrid,\r\n  setStartNode,\r\n  setEndNode,\r\n} from \"./grid-utilities\";\r\n\r\nexport default class Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isVisualizing: false,\r\n      isMouseDown: false,\r\n    };\r\n\r\n    this.startNodeIndex = props.startNodeIndex;\r\n    this.endNodeIndex = props.endNodeIndex;\r\n  }\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n\r\n    // set nextNodeState depending on current state of the node\r\n    let nextNodeState = NodeStates.WALL;\r\n    if (this.props.gridData[row][col].nodeState === NodeStates.WALL) {\r\n      nextNodeState = NodeStates.UNVISITED;\r\n    }\r\n\r\n    // set beginDragStart on StartNode click\r\n    if (this.props.gridData[row][col].isStart) {\r\n      this.beginDragStart = true;\r\n      this.setState({ isMouseDown: true });\r\n      return;\r\n    }\r\n\r\n    // set beginDragEnd on EndNode click\r\n    if (this.props.gridData[row][col].isEnd) {\r\n      this.beginDragEnd = true;\r\n      this.setState({ isMouseDown: true });\r\n      return;\r\n    }\r\n    this.tempGrid = setNodeInGrid(this.props.gridData, row, col, nextNodeState);\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseLeave = (row, col) => {\r\n    if (this.beginDragStart || this.beginDragEnd) {\r\n      const node = this.props.gridData[row][col]\r\n      node.nodeState = node.previousState\r\n    }\r\n  };\r\n\r\n  handleMouseUp() {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    if (this.beginDragStart) this.beginDragStart = false;\r\n    else if (this.beginDragEnd) this.beginDragEnd = false;\r\n\r\n    this.setState({ isMouseDown: false });\r\n\r\n    this.props.updateGrid(this.tempGrid);\r\n    this.props.updateStartEndIndex(\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    )\r\n  }\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    const node = document.getElementById(`${row}:${col}`);\r\n    const grid = this.tempGrid;\r\n\r\n    if (this.beginDragStart) {\r\n      node.className = \"StartNode\";\r\n      this.tempGrid = setStartNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.startNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.beginDragEnd) {\r\n      node.className = \"EndNode\";\r\n      this.tempGrid = setEndNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.props.endNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.state.isMouseDown) {\r\n      node.className = \"WallNode\";\r\n      this.tempGrid = setNodeInGrid(grid, row, col, NodeStates.WALL);\r\n    }\r\n  };\r\n\r\n  preventDragHandler = (e) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  renderGrid() {\r\n    this.startNodeIndex = this.props.startNodeIndex;\r\n    this.endNodeIndex = this.props.endNodeIndex;\r\n\r\n    return (\r\n      <div className=\"GridContainer\">\r\n        <div\r\n          className=\"Grid\"\r\n          onDragStart={this.preventDragHandler}\r\n          onMouseUp={() => this.handleMouseUp()}\r\n        >\r\n          {this.props.gridData.map((row, rowI) => {\r\n            return (\r\n              <div key={rowI}>\r\n                {row.map((node, nodeI) => (\r\n                  <Node\r\n                    col={node.col}\r\n                    row={node.row}\r\n                    isStart={node.isStart}\r\n                    isEnd={node.isEnd}\r\n                    isWall={node.isWall}\r\n                    shouldUpdate={node.shouldUpdate}\r\n                    nodeState={node.nodeState}\r\n                    closed={node.closed}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    onMouseDown={() => this.handleMouseDown(node.row, node.col)}\r\n                    onMouseEnter={() => this.handleMouseEnter(node.row, node.col)}\r\n                    onMouseLeave={() => this.handleMouseLeave(node.row, node.col)}\r\n                    onDragStart={this.preventDragHandler} // prevents drag on this component\r\n                    key={`${node.row}:${node.col}`}\r\n                  />\r\n                ))}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return this.renderGrid();\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./demo-node.css\";\r\nimport NodeStates from \"./node-states\";\r\n\r\nexport default class DemoNode extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            nodeState: NodeStates.UNVISITED,\r\n            isStart: false,\r\n            isEnd: false\r\n        };\r\n    }\r\n\r\n    /** Change State based on property nodeState */\r\n    static getDerivedStateFromProps(nextProps) {\r\n        return {\r\n            nodeState: nextProps.nodeState,\r\n            isStart: nextProps.isStart,\r\n            isEnd: nextProps.isEnd\r\n        };\r\n    }\r\n\r\n    render() {\r\n\r\n        if (this.props.isStart) {\r\n            return (\r\n                <div\r\n                    className=\"DemoNode\"\r\n                >\r\n                    <div\r\n                        className=\"DemoInsideStart\"></div>\r\n                </div>\r\n            );\r\n        } else if (this.props.isEnd) {\r\n            return (\r\n                <div\r\n                    className=\"DemoNode\"\r\n                >\r\n                    <div\r\n                        className=\"DemoInsideEnd\"></div>\r\n                </div >\r\n            );\r\n        } else if (this.state.nodeState === NodeStates.WALL) {\r\n            return (\r\n                <div className=\"DemoWallNode\"></div>\r\n            );\r\n        } else if (this.state.nodeState === NodeStates.UNVISITED) {\r\n            return (\r\n                <div\r\n                    className=\"DemoNode\"\r\n                >\r\n                </div>\r\n            );\r\n        } else if (this.state.nodeState === NodeStates.VISITED) {\r\n            return (\r\n                <div\r\n                    className=\"DemoVisitedNode\"\r\n                >\r\n                    <div></div>\r\n                </div>\r\n            );\r\n        } else if (this.state.nodeState === NodeStates.SHORTESTPATH) {\r\n            return (\r\n                <div\r\n                    className=\"DemoShortestPathNode\"\r\n                >\r\n                    <div></div>\r\n                </div>\r\n            );\r\n        } else {\r\n            return <div>no such state</div>;\r\n        }\r\n    }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./help.css\"\r\nimport draw from \"../assets/draw.gif\"\r\nimport selectAlgo from \"../assets/select-algo.gif\"\r\n\r\nimport DemoNode from \"./demo-node\";\r\nimport NodeStates from \"./node-states\";\r\n\r\n\r\n\r\nexport class Help extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            isVisible: true,\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.isVisible !== this.props.isVisible) {\r\n            this.setState({ isVisible: this.props.isVisible })\r\n        }\r\n    }\r\n\r\n    handleBackgroundClick = (e) => {\r\n        e.stopPropagation();\r\n        this.props.toggleHelpPanel()\r\n    }\r\n\r\n    handlePanelClick = (e) => {\r\n        e.stopPropagation();\r\n    }\r\n\r\n    render() {\r\n        if (this.state.isVisible) {\r\n            return (\r\n                <div className=\"Background\" onClick={this.handleBackgroundClick}>\r\n                    <div className=\"HelpContainer\" onClick={this.handlePanelClick}>\r\n                        <h2 className=\"Title\">Welcome To My Pathfinding Visualizer</h2>\r\n\r\n                        <div className=\"NodeDisplay\">\r\n                            <div className=\"NodeContainer\">\r\n                                <DemoNode nodeState={NodeStates.UNVISITED} isStart={true} />\r\n                                    Start Node\r\n                                </div>\r\n\r\n                            <div className=\"NodeContainer\">\r\n                                <DemoNode nodeState={NodeStates.UNVISITED} isEnd={true} />\r\n                                    End Node\r\n                                </div>\r\n\r\n                            <div className=\"NodeContainer\">\r\n                                <DemoNode nodeState={NodeStates.WALL} isStart={false} />\r\n                                    Wall Node\r\n                                </div>\r\n\r\n                            <div className=\"NodeContainer\">\r\n                                <DemoNode nodeState={NodeStates.VISITED} isStart={false} />\r\n                                    Visited Node\r\n                                </div>\r\n\r\n                            <div className=\"NodeContainer\">\r\n                                <DemoNode nodeState={NodeStates.SHORTESTPATH} />\r\n                                    Path Node\r\n                                </div>\r\n                        </div>\r\n\r\n                        <div className=\"Card\">\r\n                            <div className=\"NodeContainer\">\r\n                                <img src={selectAlgo} width=\"530px\" height=\"75px\" alt=\"\" />\r\n                                <span className=\"Text\">Select a path finding or maze algorithm!</span>\r\n                            </div>\r\n\r\n                            <div className=\"NodeContainer\">\r\n                                <img src={draw} width=\"200px\" height=\"200px\" alt=\"\" />\r\n                                <span className=\"Text\">Draw walls by clicking and dragging!</span>\r\n                            </div>\r\n                        </div>\r\n\r\n                        <button className=\"CloseButton\" onClick={this.handleBackgroundClick}>Got It!</button>\r\n                    </div>\r\n                </div >\r\n\r\n            );\r\n        } else {\r\n            return (\r\n                <div></div>\r\n            )\r\n        }\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport {\r\n    setStartNode,\r\n    setEndNode\r\n} from '../path-finding-visualizer/grid-utilities'\r\n\r\n\r\nexport function executeBinaryTree(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    let toReturn = [];\r\n\r\n    for (let i = 1; i < grid.length; i += 2) {\r\n        for (let j = 1; j < grid[0].length; j += 2) {\r\n            let neighbours = [];\r\n\r\n            if (i - 1 > 0)\r\n                neighbours.push(grid[i - 1][j])\r\n            if (j - 1 > 0)\r\n                neighbours.push(grid[i][j - 1])\r\n\r\n            if (grid[i][j] === grid[1][1])\r\n                grid[i][j].closed = true;\r\n\r\n            if (neighbours.length === 0)\r\n                continue;\r\n\r\n            startNode.nodeState = NodeStates.UNVISITED;\r\n            endNode.NodeState = NodeStates.UNVISITED;\r\n\r\n            const rand = neighbours[Math.floor(Math.random() * neighbours.length)];\r\n\r\n            grid[i][j].closed = true;\r\n            grid[rand.row][rand.col].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\n\r\n\r\nexport function executeRandom(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const rand = Math.random();\r\n            if(rand > 0.3333333) grid[i][j].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","/***\r\n * An array implementation of a MinHeap\r\n * This implementation of MinHeap is meant to be used to store the Node object\r\n * The Node.distance will be used to compare and sort the nodes in the heap\r\n */\r\nexport default class MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n        this.map = new Map();\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    getNodeAt(key) {\r\n        const heapIndex = this.map.get(key);\r\n        const node = this.heap[heapIndex];\r\n        return node;\r\n    }\r\n\r\n    isHeap() {\r\n        // Start from root and go till the last internal \r\n        // node \r\n        for (let i = 0; i <= (this.heap.length - 2) / 2; i++) {\r\n            // If left child is greater, return false \r\n            if (this.heap[2 * i + 1] > this.heap[i])\r\n                return false;\r\n\r\n            // If right child is greater, return false \r\n            if (2 * i + 2 < this.heap.length && this.heap[2 * i + 2] > this.heap[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    insert(node) {\r\n        this.heap.push(node);\r\n        this.map.set(`${node.row}:${node.col}`, node);\r\n\r\n        let index = this.heap.length - 1;\r\n\r\n        while (index > 0) {\r\n            let element = this.heap[index];\r\n            let parent = this.heap[Math.floor((index - 1) / 2)];\r\n\r\n            if (parent.distance < element.distance) break;\r\n\r\n\r\n            this.swap(index, Math.floor((index - 1) / 2))\r\n            index = Math.floor((index - 1) / 2);\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        let smallest = this.heap[0];\r\n        this.map.delete(`${smallest.row}:${smallest.col}`);\r\n        this.heap[0] = this.heap.pop();\r\n        this.sinkDown(0);\r\n        return smallest;\r\n    }\r\n\r\n    sinkDown(index) {\r\n        let left = 2 * index + 1;\r\n        let right = 2 * index + 2;\r\n        let smallest = index;\r\n        const length = this.heap.length;\r\n\r\n        // if left child is greater than parent\r\n        if (\r\n            left < length &&\r\n            this.heap[left].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = left;\r\n        }\r\n        // if right child is greater than parent\r\n        if (\r\n            right < length &&\r\n            this.heap[right].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = right;\r\n        }\r\n        // swap\r\n        if (smallest !== index) {\r\n            this.swap(index, smallest)\r\n            this.sinkDown(smallest);\r\n        }\r\n    }\r\n\r\n    changeDistance(node, distance) {\r\n        // get node in map and set distance\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n\r\n        this.heap[heapIndex].distance = distance;\r\n\r\n        // heapify tree\r\n        while (heapIndex !== 0 && this.heap[heapIndex].distance < this.heap[Math.floor((heapIndex - 1) / 2)].distance) {\r\n            this.swap(heapIndex, Math.floor((heapIndex - 1) / 2))\r\n            heapIndex = Math.floor((heapIndex - 1) / 2);\r\n        }\r\n    }\r\n\r\n    setPreviousNode(node, previousNode) {\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n        this.heap[heapIndex].previousNode = previousNode;\r\n    }\r\n\r\n\r\n    swap(index1, index2){\r\n        const temp = this.heap[index1];\r\n        this.heap[index1] = this.heap[index2];\r\n        this.heap[index2] = temp;\r\n\r\n        this.map.set(`${this.heap[index1].row}:${this.heap[index1].col}`, index1)\r\n        this.map.set(`${this.heap[index2].row}:${this.heap[index2].col}`, index2)\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeAStar(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      grid[i][j].distance = 0;\r\n      grid[i][j].closed = false;\r\n    }\r\n  }\r\n\r\n  var t0 = performance.now();\r\n\r\n  // init open and closed lists\r\n  startNode.distance = 0;\r\n  let open = new MinHeap();\r\n  let closed = [];\r\n\r\n  // add start node to open\r\n  open.insert(startNode);\r\n\r\n  // while open is not empty\r\n  while (open.map.size > 0) {\r\n    // remove the node with the smallest fCost\r\n    let closestNode = open.remove();\r\n    closed.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"AStar Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return closed;\r\n    }\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) {\r\n      continue;\r\n    }\r\n\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return closed;\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED\r\n\r\n    const neighbours = getAvailableNeighbours(closestNode, grid);\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (\r\n        closed.includes(neighbours[i]) ||\r\n        neighbours[i].nodeState === NodeStates.WALL\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // let gCost = closestNode.gCost + 10;\r\n      let gCost = closestNode.gCost + getNewGCost(neighbours[i], closestNode);\r\n\r\n      if (\r\n        open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n        undefined ||\r\n        gCost < neighbours[i].gCost\r\n      ) {\r\n        neighbours[i].previousNode = closestNode;\r\n        neighbours[i].hCost = getManhattanHCost(neighbours[i], endNode);\r\n        neighbours[i].gCost = gCost;\r\n        neighbours[i].distance = neighbours[i].gCost + neighbours[i].hCost;\r\n\r\n        if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n          undefined\r\n        ) {\r\n          open.insert(neighbours[i]);\r\n        } else if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) !==\r\n          undefined\r\n        ) {\r\n          open.changeDistance(neighbours[i], neighbours[i].distance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return closed;\r\n}\r\n\r\nexport function getAvailableNeighbours(node, grid) {\r\n  let neighbours = [];\r\n\r\n  if (node.row - 1 >= 0) neighbours.push(grid[node.row - 1][node.col]);\r\n\r\n  if (node.col + 1 < grid[0].length)\r\n    neighbours.push(grid[node.row][node.col + 1]);\r\n\r\n  if (node.row + 1 < grid.length) neighbours.push(grid[node.row + 1][node.col]);\r\n\r\n  if (node.col - 1 >= 0) neighbours.push(grid[node.row][node.col - 1]);\r\n\r\n  return neighbours;\r\n}\r\n\r\nconst getManhattanHCost = (currentNode, destNode) => {\r\n  const y = Math.abs(currentNode.row - destNode.row);\r\n  const x = Math.abs(currentNode.col - destNode.col);\r\n  return (x + y) * 9.9;\r\n};\r\n\r\nconst getNewGCost = (currentNode, closestNode) => {\r\n  if (closestNode.previousNode === null) {\r\n    return 10;\r\n  }\r\n\r\n  let firstDirection = [\r\n    closestNode.previousNode.row - closestNode.row,\r\n    closestNode.previousNode.col - closestNode.col,\r\n  ];\r\n  let secondDirection = [\r\n    closestNode.row - currentNode.row,\r\n    closestNode.col - currentNode.col,\r\n  ];\r\n\r\n  if (\r\n    firstDirection[0] === secondDirection[0] &&\r\n    firstDirection[1] === secondDirection[1]\r\n  ) {\r\n    return 9;\r\n  } else {\r\n    return 10;\r\n  }\r\n};\r\n\r\nexport const getShortestPath = (startNode, endNode) => {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== startNode) {\r\n    if (currentNode === null || currentNode === undefined) break;\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  shortestPath.push(startNode);\r\n  return shortestPath.reverse();\r\n};","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeDijkstra(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  var t0 = performance.now();\r\n\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = new MinHeap();\r\n  unvisitedNodes = getAllNodesHeap(grid);\r\n  const visitedNodesInOrder = [];\r\n\r\n  visitedNodesInOrder.push(startNode)\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    const closestNode = unvisitedNodes.remove();\r\n    const neighbours = getAvailableNeighboursHeap(closestNode, unvisitedNodes);\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) continue;\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const newDistance = closestNode.distance + 1;\r\n\r\n      unvisitedNodes.changeDistance(neighbours[i], newDistance);\r\n      unvisitedNodes.setPreviousNode(neighbours[i], closestNode);\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED;\r\n    closestNode.closed = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"Dijkstra Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getAllNodesHeap(grid) {\r\n  const nodes = new MinHeap();\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      nodes.insert(grid[row][col]);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getAvailableNeighboursHeap(node, heap) {\r\n  let neighbours = [];\r\n\r\n  const topNeighbour = heap.getNodeAt(`${node.row - 1}:${node.col}`);\r\n  if (topNeighbour !== undefined) neighbours.push(topNeighbour);\r\n\r\n  const rightNeighbour = heap.getNodeAt(`${node.row}:${node.col + 1}`);\r\n  if (rightNeighbour !== undefined) neighbours.push(rightNeighbour);\r\n\r\n  const bottomNeighbour = heap.getNodeAt(`${node.row + 1}:${node.col}`);\r\n  if (bottomNeighbour !== undefined) neighbours.push(bottomNeighbour);\r\n\r\n  const leftNeighbour = heap.getNodeAt(`${node.row}:${node.col - 1}`);\r\n  if (leftNeighbour !== undefined) neighbours.push(leftNeighbour);\r\n\r\n  //   return neighbours.filter(\r\n  //     (neighbour) => neighbour.nodeState === NodeStates.UNVISITED\r\n  //   );\r\n\r\n  return neighbours.filter((neighbour) => neighbour.closed !== true);\r\n}\r\n\r\nexport function getShortestPath(endNode) {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    currentNode.nodeState = NodeStates.SHORTESTPATH;\r\n    shortestPath.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return shortestPath;\r\n}","import React, { Component } from \"react\";\r\nimport \"./path-finding-visualizer.css\";\r\nimport Grid from \"./grid\";\r\nimport NodeStates from \"./node-states\";\r\nimport {\r\n  createGrid,\r\n  replaceGrid,\r\n  clearVisitedNodes,\r\n  clearWallNodes,\r\n} from \"./grid-utilities\";\r\nimport { Help } from \"./help\";\r\nimport { executeBinaryTree } from '../algorithms/binary-tree';\r\nimport { executeRandom } from '../algorithms/random';\r\nimport { executeAStar, getShortestPath } from \"../algorithms/a-star\";\r\nimport { executeDijkstra } from \"../algorithms/dijkstra\";\r\nimport Dropdown from \"react-bootstrap/Dropdown\";\r\nimport DropdownButton from \"react-bootstrap/Dropdownbutton\";\r\n\r\nexport default class PathFindindVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isHelpVisible: true,\r\n      selectedAlgo: executeDijkstra,\r\n      selectedAlgoName: \"Dijkstra\",\r\n      selectedMazeAlgo: executeBinaryTree,\r\n      selectedMazeAlgoName: \"Binary Tree\",\r\n      width: 0,\r\n      height: 0,\r\n      isVisualizing: false,\r\n      startNodeIndex: { row: 10, col: 5 },\r\n      endNodeIndex: { row: 10, col: 30 },\r\n      grid: [],\r\n    };\r\n\r\n    this.visitedAnimationTimeout = []\r\n    this.shortestPathTimeout = [];\r\n    this.isMaze = false;\r\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.updateArrayLength();\r\n    window.addEventListener(\"resize\", this.updateWindowDimensions);\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateWindowDimensions);\r\n  }\r\n\r\n  updateWindowDimensions() {\r\n    this.updateArrayLength();\r\n    this.reset();\r\n\r\n    if (this.state.startNodeIndex.row < 0 ||\r\n      this.state.startNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.startNodeIndex.col < 0 ||\r\n      this.state.startNodeIndex.col > this.state.grid[0].length - 1 ||\r\n      this.state.endNodeIndex.row < 0 ||\r\n      this.state.endNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.endNodeIndex.col < 0 ||\r\n      this.state.endNodeIndex.col > this.state.grid[0].length - 1) {\r\n      this.setState({\r\n        startNodeIndex: { row: Math.floor(0), col: Math.floor(0) },\r\n        endNodeIndex: { row: Math.floor(this.rowCount - 1), col: Math.floor(this.colCount - 1) },\r\n      })\r\n    }\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({\r\n      grid: newGrid,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  }\r\n\r\n  updateArrayLength() {\r\n    this.nodeSize = 24;\r\n    this.rowCount = Math.floor(\r\n      (window.innerHeight - window.innerHeight / 5) / this.nodeSize\r\n    );\r\n    this.colCount = Math.floor(\r\n      (window.innerWidth - window.innerWidth / 18) / this.nodeSize\r\n    );\r\n\r\n    if (this.colCount % 2 === 0)\r\n      this.colCount -= 1;\r\n\r\n    if (this.rowCount % 2 === 0)\r\n      this.rowCount -= 1;\r\n\r\n    let root = document.documentElement;\r\n    root.style.setProperty(\"--nodeSize\", this.nodeSize + \"px\");\r\n  }\r\n\r\n  reset() {\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    Array.from(this.shortestPathTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    });\r\n    Array.from(this.visitedAnimationTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    })\r\n\r\n    this.isMaze = false;\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    this.setState({ isVisualizing: false });\r\n  }\r\n\r\n  executePathfinding() {\r\n    if (this.state.isVisualizing) return;\r\n    clearTimeout(this.shortestPathTimeout);\r\n    clearTimeout(this.visitedAnimationTimeout);\r\n\r\n    const newGrid = replaceGrid(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const visitedNodesInOrder = this.state.selectedAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    const shortestPathNodes = getShortestPath(\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.visualize(visitedNodesInOrder, shortestPathNodes);\r\n  }\r\n\r\n  // Visualize visited nodes and shortest path (by calling visualizeShortestPath) on\r\n  visualize = (visitedNodesInOrder, shortestPath) => {\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (visitedNodesInOrder.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        this.shortestPathTimeout.push(setTimeout(() => {\r\n          this.visualizeShortestPath(shortestPath);\r\n        }, 5 * i))\r\n      }\r\n\r\n      const node = document.getElementById(`${visitedNodesInOrder[i].row}:${visitedNodesInOrder[i].col}`);\r\n      this.visitedAnimationTimeout.push(setTimeout(() => {\r\n        node.className = \"VisitedNode\";\r\n      }, 5 * i))\r\n    }\r\n  }\r\n\r\n  // Visualize shortestPath from array recieved in params\r\n  visualizeShortestPath(shortestPath) {\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (shortestPath.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const node = document.getElementById(`${shortestPath[i].row}:${shortestPath[i].col}`);\r\n      this.shortestPathTimeout.push(setTimeout(() => {\r\n        node.className = \"ShortestPathNode\";\r\n      }, 40 * i))\r\n      toWaitBeforeEnded += 40;\r\n    }\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n  }\r\n\r\n  visualizeMaze() {\r\n    if (this.state.isVisualizing) return;\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const maze = this.state.selectedMazeAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.setState({ isVisualizing: true });\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 1; i < maze.length; i++) {\r\n      const row = maze[i].row;\r\n      const col = maze[i].col;\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      if (this.isMaze) {\r\n        maze[i].nodeState = NodeStates.WALL;\r\n        node.className = \"WallNode\";\r\n      } else {\r\n        this.visitedAnimationTimeout.push(setTimeout(() => {\r\n          maze[i].nodeState = NodeStates.WALL;\r\n          node.className = \"WallNode\";\r\n        }, 3 * i))\r\n        toWaitBeforeEnded += 3;\r\n      }\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n\r\n    this.isMaze = true;\r\n  }\r\n\r\n  updateGrid = (newGrid) => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  updateStartEndIndex = (startNode, endNode) => {\r\n    this.setState({ startNodeIndex: startNode })\r\n    this.setState({ endNodeIndex: endNode });\r\n  };\r\n\r\n  selectAlgorithm = (selectedAlgo) => {\r\n    if (selectedAlgo === \"Dijkstra\") this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    if (selectedAlgo === \"A*\") this.setState({ selectedAlgo: executeAStar, selectedAlgoName: \"A*\" });\r\n    if (selectedAlgo === \"BinaryTree\") this.setState({ selectedMazeAlgo: executeBinaryTree, selectedMazeAlgoName: \"Binary Tree\" })\r\n    if (selectedAlgo === \"Random\") this.setState({ selectedMazeAlgo: executeRandom, selectedMazeAlgoName: \"Random\" })\r\n  };\r\n\r\n  toggleHelpPanel = () => {\r\n    this.setState({ isHelpVisible: !this.state.isHelpVisible })\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div style={{ height: \"100vh\" }} className=\"PathFindingVisualizer\">\r\n        <div className=\"Header\">\r\n          <div className=\"SubHeader\">\r\n            <h1 className=\"TitleText\">Pathfinding Visualizer</h1>\r\n          </div>\r\n\r\n          <div className=\"SubHeader\">\r\n            <DropdownButton id=\"DropDown\" title=\"Pathfinding Algorithm \">\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('Dijkstra')}>Dijkstra's Algorithm</Dropdown.Item>\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('A*')} as=\"button\">A* Algorithm</Dropdown.Item>\r\n            </DropdownButton>\r\n\r\n            <button className=\"MainButton\" onClick={() => this.executePathfinding()}>Visualize {this.state.selectedAlgoName}</button>\r\n          </div>\r\n\r\n\r\n          <div className=\"SubHeader\">\r\n            <DropdownButton id=\"DropDown\" title=\"Maze Algorithm \">\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"BinaryTree\")} as=\"button\">Binary Tree</Dropdown.Item>\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"Random\")} as=\"button\">Random</Dropdown.Item>\r\n            </DropdownButton>\r\n\r\n            <button className=\"MainButton\" onClick={() => this.visualizeMaze()}>{this.state.selectedMazeAlgoName} Maze</button>\r\n          </div>\r\n\r\n\r\n          <div className=\"SubHeader\">\r\n            <button className=\"SimpleTextButton\" onClick={() => this.reset()}>Reset</button>\r\n            <button className=\"SimpleTextButton\" onClick={() => this.toggleHelpPanel()}>Help</button>\r\n          </div>\r\n        </div>\r\n\r\n        <Help isVisible={this.state.isHelpVisible} toggleHelpPanel={this.toggleHelpPanel}></Help>\r\n\r\n        <Grid\r\n          updateGrid={this.updateGrid}\r\n          updateStartEndIndex={this.updateStartEndIndex}\r\n          gridData={this.state.grid}\r\n          startNodeIndex={this.state.startNodeIndex}\r\n          endNodeIndex={this.state.endNodeIndex}\r\n          isVisualizing={(this.state.isVisualizing)}\r\n        />\r\n      </div >\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './path-finding-visualizer/path-finding-visualizer'\r\n\r\nfunction App() {\r\n  return (\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}