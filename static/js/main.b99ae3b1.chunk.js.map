{"version":3,"sources":["path-finding-visualizer/node-states.js","path-finding-visualizer/node.jsx","path-finding-visualizer/grid-utilities.js","path-finding-visualizer/grid.jsx","algorithms/binary-tree.js","algorithms/random.js","data-structures/min-heap.js","algorithms/a-star.js","algorithms/dijkstra.js","path-finding-visualizer/path-finding-visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["NodeStates","VISITED","UNVISITED","WALL","SHORTESTPATH","Node","props","state","nodeState","isStart","isEnd","nextProps","hasNodeStateChanged","this","isStartChanged","isEndChanged","row","col","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","id","onDragStart","preventDragHandler","className","Component","createGrid","rowCount","colCount","startNodeIndex","endNodeIndex","grid","i","j","push","createNode","distance","Infinity","gCost","hCost","previousState","closed","previousNode","setNodeInGrid","node","newNode","previousNodeState","clearVisitedNodes","length","document","getElementById","clearWallNodes","getClassFromState","Grid","handleMouseDown","isVisualizing","nextNodeState","gridData","beginDragStart","beginDragEnd","tempGrid","setState","isMouseDown","handleMouseDownIntersect","isVisusualizing","handleMouseLeave","handleMouseEnter","newGrid","newStartNode","firstElementChild","setStartNode","newEndNode","setEndNode","e","preventDefault","updateGrid","updateStartEndIndex","handleMouseUp","map","rowI","key","nodeI","isWall","shouldUpdate","renderGrid","executeBinaryTree","startNode","endNode","neighbours","NodeState","rand","Math","floor","random","filter","neighbour","getAllNodesInGrid","executeRandom","MinHeap","heap","Map","heapIndex","get","set","index","element","swap","smallest","delete","pop","sinkDown","left","right","index1","index2","temp","executeAStar","t0","performance","now","open","insert","size","closestNode","remove","t1","console","log","getAvailableNeighbours","includes","getNewGCost","undefined","getNodeAt","getManhattanHCost","changeDistance","currentNode","destNode","y","abs","firstDirection","secondDirection","executeDijkstra","unvisitedNodes","nodes","getAllNodesHeap","visitedNodesInOrder","getAvailableNeighboursHeap","newDistance","setPreviousNode","topNeighbour","rightNeighbour","bottomNeighbour","leftNeighbour","PathFindindVisualizer","visualize","shortestPath","shortestPathTimeout","setTimeout","visualizeShortestPath","visitedAnimationTimeout","selectAlgorithm","selectedAlgo","selectedAlgoName","selectedMazeAlgo","selectedMazeAlgoName","width","height","isMaze","updateWindowDimensions","bind","updateArrayLength","window","addEventListener","removeEventListener","reset","innerWidth","innerHeight","nodeSize","documentElement","style","setProperty","Array","from","forEach","clearTimeout","replaceGrid","shortestPathNodes","reverse","getShortestPath","toWaitBeforeEnded","maze","DropdownButton","title","Dropdown","Item","onClick","as","executePathfinding","visualizeMaze","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b99ae3b1.chunk.js","sourcesContent":["const NodeStates = {\r\n    VISITED: \"visited\",\r\n    UNVISITED: \"unvisited\",\r\n    WALL: \"wall\",\r\n    SHORTESTPATH: 'shortestPath'\r\n  };\r\n\r\nexport default NodeStates;\r\n","import React, { Component } from \"react\";\r\nimport \"./grid.css\";\r\nimport NodeStates from \"./node-states\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodeState: NodeStates.UNVISITED,\r\n      isStart: false,\r\n      isEnd: false\r\n    };\r\n  }\r\n\r\n  /** Make sure not all nodes update every time the grid renders */\r\n  shouldComponentUpdate(nextProps) {\r\n    const hasNodeStateChanged = this.props.nodeState !== nextProps.nodeState;\r\n    const isStartChanged = this.props.isStart !== nextProps.isStart;\r\n    const isEndChanged = this.props.isEnd !== nextProps.isEnd;\r\n\r\n    return hasNodeStateChanged || isStartChanged || isEndChanged;\r\n  }\r\n\r\n  /** Change State based on property nodeState */\r\n  static getDerivedStateFromProps(nextProps) {\r\n    return {\r\n      nodeState: nextProps.nodeState,\r\n      isStart: nextProps.isStart,\r\n      isEnd: nextProps.isEnd\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { row, col, onMouseDown, onMouseEnter, onMouseUp, onMouseLeave } = this.props;\r\n\r\n    if (this.props.isStart) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"StartNode\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-start\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.props.isEnd) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"EndNode\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-end\"></div>\r\n        </div >\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.WALL) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"WallNode\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.UNVISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`} className=\"\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.VISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"VisitedNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.SHORTESTPATH) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"ShortestPathNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else {\r\n      return <div>no such state</div>;\r\n    }\r\n  }\r\n}\r\n","import NodeStates from \"./node-states\";\r\n\r\nexport const createGrid = (\r\n  rowCount,\r\n  colCount,\r\n  startNodeIndex,\r\n  endNodeIndex\r\n) => {\r\n  let grid = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let row = [];\r\n\r\n    for (let j = 0; j < colCount; j++) {\r\n      row.push(createNode(i, j, startNodeIndex, endNodeIndex));\r\n    }\r\n    grid.push(row);\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const createNode = (row, col, startNodeIndex, endNodeIndex) => {\r\n  let isStart = false;\r\n  let isEnd = false;\r\n\r\n  if (row === startNodeIndex.row && col === startNodeIndex.col) isStart = true;\r\n  else if (row === endNodeIndex.row && col === endNodeIndex.col) isEnd = true;\r\n\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: isStart,\r\n    isEnd: isEnd,\r\n    distance: Infinity,\r\n    gCost: 0,\r\n    hCost: 0,\r\n    previousState: NodeStates.UNVISITED,\r\n    closed: false,\r\n    previousNode: null,\r\n    nodeState: NodeStates.UNVISITED,\r\n  };\r\n};\r\n\r\nexport const setNodeInGrid = (grid, row, col, nodeState) => {\r\n  const node = grid[row][col];\r\n\r\n  const newNode = {\r\n    ...node,\r\n    previousNodeState: nodeState,\r\n    nodeState: nodeState,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nexport const setStartNode = (grid, row, col, startNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newStartNode = {\r\n    ...node,\r\n    previousState: previousState,\r\n    isStart: true,\r\n  };\r\n\r\n  newGrid[row][col] = newStartNode;\r\n  newGrid[startNodeIndex.row][startNodeIndex.col].isStart = false;\r\n  document.getElementById(\r\n    `${startNodeIndex.row}:${startNodeIndex.col}`\r\n  ).className = getClassFromState(grid[startNodeIndex.row][startNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-start\"\r\n\r\n  document.getElementById(`${startNodeIndex.row}:${startNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  startNodeIndex.row = row;\r\n  startNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const setEndNode = (grid, row, col, endNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newEndNode = {\r\n    ...node,\r\n    nodeState: NodeStates.UNVISITED,\r\n    previousState: previousState,\r\n    isEnd: true,\r\n  };\r\n\r\n  newGrid[row][col] = newEndNode;\r\n  newGrid[endNodeIndex.row][endNodeIndex.col].isEnd = false;\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`).className =\r\n    getClassFromState(grid[endNodeIndex.row][endNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-end\"\r\n\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  endNodeIndex.row = row;\r\n  endNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const replaceGrid = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n        grid[i][j].nodeState = NodeStates.WALL;\r\n        grid[i][j].closed = false;\r\n      } else {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const clearVisitedNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        continue;\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const clearWallNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        node.className = \"Node\";\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst getClassFromState = (state) => {\r\n  if (state === NodeStates.UNVISITED) return \"Node\"\r\n  if (state === NodeStates.VISITED) return \"VisitedNodeNoAnim\"\r\n  if (state === NodeStates.WALL) return \"WallNode\"\r\n  if (state === NodeStates.SHORTESTPATH) return \"ShortestPathNodeNoAnim\"\r\n}","import React, { Component } from \"react\";\r\nimport Node from \"./node\";\r\nimport NodeStates from \"./node-states\";\r\nimport \"./grid.css\";\r\nimport {\r\n  setNodeInGrid,\r\n  setStartNode,\r\n  setEndNode,\r\n} from \"./grid-utilities\";\r\n\r\nexport default class Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isVisualizing: false,\r\n      isMouseDown: false,\r\n    };\r\n\r\n    this.startNodeIndex = props.startNodeIndex;\r\n    this.endNodeIndex = props.endNodeIndex;\r\n  }\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n\r\n    // set nextNodeState depending on current state of the node\r\n    let nextNodeState = NodeStates.WALL;\r\n    if (this.props.gridData[row][col].nodeState === NodeStates.WALL) {\r\n      nextNodeState = NodeStates.UNVISITED;\r\n    }\r\n\r\n    // set beginDragStart on StartNode click\r\n    if (this.props.gridData[row][col].isStart) {\r\n      this.beginDragStart = true;\r\n      return;\r\n    }\r\n\r\n    // set beginDragEnd on EndNode click\r\n    if (this.props.gridData[row][col].isEnd) {\r\n      this.beginDragEnd = true;\r\n      return;\r\n    }\r\n\r\n    // set State to t\r\n    this.tempGrid = setNodeInGrid(this.props.gridData, row, col, nextNodeState);\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseDownIntersect = () => {\r\n    if (this.state.isVisusualizing) return;\r\n    this.tempGrid = this.props.gridData;\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseLeave = (row, col) => {\r\n    if (this.beginDragStart || this.beginDragEnd) {\r\n      const node = this.props.gridData[row][col]\r\n      node.nodeState = node.previousState\r\n    }\r\n  };\r\n\r\n  handleMouseUp() {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    if (this.beginDragStart) this.beginDragStart = false;\r\n    else if (this.beginDragEnd) this.beginDragEnd = false;\r\n\r\n    // set new grid and isMouseDown in state\r\n    this.setState({ isMouseDown: false });\r\n\r\n    this.props.updateGrid(this.tempGrid);\r\n    this.props.updateStartEndIndex(\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    )\r\n  }\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    const node = document.getElementById(`${row}:${col}`);\r\n    const grid = this.tempGrid;\r\n\r\n    if (this.beginDragStart) {\r\n      node.className = \"StartNode\";\r\n      this.tempGrid = setStartNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.startNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.beginDragEnd) {\r\n      node.className = \"EndNode\";\r\n      this.tempGrid = setEndNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.props.endNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.state.isMouseDown) {\r\n      node.className = \"WallNode\";\r\n      this.tempGrid = setNodeInGrid(grid, row, col, NodeStates.WALL);\r\n    }\r\n  };\r\n\r\n  preventDragHandler = (e) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  renderGrid() {\r\n    this.startNodeIndex = this.props.startNodeIndex;\r\n    this.endNodeIndex = this.props.endNodeIndex;\r\n\r\n    return (\r\n      <div className=\"GridContainer\">\r\n        <div\r\n          className=\"Grid\"\r\n          onDragStart={this.preventDragHandler}\r\n          // onMouseLeave={this.handleMouseLeave}\r\n          onMouseUp={() => this.handleMouseUp()}\r\n          onMouseDown={() => this.handleMouseDownIntersect()}\r\n        >\r\n          {this.props.gridData.map((row, rowI) => {\r\n            return (\r\n              <div key={rowI}>\r\n                {row.map((node, nodeI) => (\r\n                  <Node\r\n                    col={node.col}\r\n                    row={node.row}\r\n                    isStart={node.isStart}\r\n                    isEnd={node.isEnd}\r\n                    isWall={node.isWall}\r\n                    shouldUpdate={node.shouldUpdate}\r\n                    nodeState={node.nodeState}\r\n                    closed={node.closed}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    onMouseDown={() => this.handleMouseDown(node.row, node.col)}\r\n                    onMouseEnter={() => this.handleMouseEnter(node.row, node.col)}\r\n                    onMouseLeave={() => this.handleMouseLeave(node.row, node.col)}\r\n                    onDragStart={this.preventDragHandler} // prevents drag on this component\r\n                    key={`${node.row}:${node.col}`}\r\n                  />\r\n                ))}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return this.renderGrid();\r\n  }\r\n}\r\n","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport {\r\n    setStartNode,\r\n    setEndNode\r\n} from '../path-finding-visualizer/grid-utilities'\r\n\r\n\r\nexport function executeBinaryTree(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    let toReturn = [];\r\n\r\n    for (let i = 1; i < grid.length; i += 2) {\r\n        for (let j = 1; j < grid[0].length; j += 2) {\r\n            let neighbours = [];\r\n\r\n            if (i - 1 > 0)\r\n                neighbours.push(grid[i - 1][j])\r\n            if (j - 1 > 0)\r\n                neighbours.push(grid[i][j - 1])\r\n\r\n            if (grid[i][j] === grid[1][1])\r\n                grid[i][j].closed = true;\r\n\r\n            if (neighbours.length === 0)\r\n                continue;\r\n\r\n            startNode.nodeState = NodeStates.UNVISITED;\r\n            endNode.NodeState = NodeStates.UNVISITED;\r\n\r\n            const rand = neighbours[Math.floor(Math.random() * neighbours.length)];\r\n\r\n            grid[i][j].closed = true;\r\n            grid[rand.row][rand.col].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\n\r\n\r\nexport function executeRandom(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const rand = Math.random();\r\n            if(rand > 0.3333333) grid[i][j].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","/***\r\n * An array implementation of a MinHeap\r\n * This implementation of MinHeap is meant to be used to store the Node object\r\n * The Node.distance will be used to compare and sort the nodes in the heap\r\n */\r\nexport default class MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n        this.map = new Map();\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    getNodeAt(key) {\r\n        const heapIndex = this.map.get(key);\r\n        const node = this.heap[heapIndex];\r\n        return node;\r\n    }\r\n\r\n    isHeap() {\r\n        // Start from root and go till the last internal \r\n        // node \r\n        for (let i = 0; i <= (this.heap.length - 2) / 2; i++) {\r\n            // If left child is greater, return false \r\n            if (this.heap[2 * i + 1] > this.heap[i])\r\n                return false;\r\n\r\n            // If right child is greater, return false \r\n            if (2 * i + 2 < this.heap.length && this.heap[2 * i + 2] > this.heap[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    insert(node) {\r\n        this.heap.push(node);\r\n        this.map.set(`${node.row}:${node.col}`, node);\r\n\r\n        let index = this.heap.length - 1;\r\n\r\n        while (index > 0) {\r\n            let element = this.heap[index];\r\n            let parent = this.heap[Math.floor((index - 1) / 2)];\r\n\r\n            if (parent.distance < element.distance) break;\r\n\r\n\r\n            this.swap(index, Math.floor((index - 1) / 2))\r\n            index = Math.floor((index - 1) / 2);\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        let smallest = this.heap[0];\r\n        this.map.delete(`${smallest.row}:${smallest.col}`);\r\n        this.heap[0] = this.heap.pop();\r\n        this.sinkDown(0);\r\n        return smallest;\r\n    }\r\n\r\n    sinkDown(index) {\r\n        let left = 2 * index + 1;\r\n        let right = 2 * index + 2;\r\n        let smallest = index;\r\n        const length = this.heap.length;\r\n\r\n        // if left child is greater than parent\r\n        if (\r\n            left < length &&\r\n            this.heap[left].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = left;\r\n        }\r\n        // if right child is greater than parent\r\n        if (\r\n            right < length &&\r\n            this.heap[right].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = right;\r\n        }\r\n        // swap\r\n        if (smallest !== index) {\r\n            this.swap(index, smallest)\r\n            this.sinkDown(smallest);\r\n        }\r\n    }\r\n\r\n    changeDistance(node, distance) {\r\n        // get node in map and set distance\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n\r\n        this.heap[heapIndex].distance = distance;\r\n\r\n        // heapify tree\r\n        while (heapIndex !== 0 && this.heap[heapIndex].distance < this.heap[Math.floor((heapIndex - 1) / 2)].distance) {\r\n            this.swap(heapIndex, Math.floor((heapIndex - 1) / 2))\r\n            heapIndex = Math.floor((heapIndex - 1) / 2);\r\n        }\r\n    }\r\n\r\n    setPreviousNode(node, previousNode) {\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n        this.heap[heapIndex].previousNode = previousNode;\r\n    }\r\n\r\n\r\n    swap(index1, index2){\r\n        const temp = this.heap[index1];\r\n        this.heap[index1] = this.heap[index2];\r\n        this.heap[index2] = temp;\r\n\r\n        this.map.set(`${this.heap[index1].row}:${this.heap[index1].col}`, index1)\r\n        this.map.set(`${this.heap[index2].row}:${this.heap[index2].col}`, index2)\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeAStar(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      grid[i][j].distance = 0;\r\n      grid[i][j].closed = false;\r\n    }\r\n  }\r\n\r\n  var t0 = performance.now();\r\n\r\n  // init open and closed lists\r\n  startNode.distance = 0;\r\n  let open = new MinHeap();\r\n  let closed = [];\r\n\r\n  // add start node to open\r\n  open.insert(startNode);\r\n\r\n  // while open is not empty\r\n  while (open.map.size > 0) {\r\n    // remove the node with the smallest fCost\r\n    let closestNode = open.remove();\r\n    closed.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"AStar Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return closed;\r\n    }\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) {\r\n      continue;\r\n    }\r\n\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return closed;\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED\r\n\r\n    const neighbours = getAvailableNeighbours(closestNode, grid);\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (\r\n        closed.includes(neighbours[i]) ||\r\n        neighbours[i].nodeState === NodeStates.WALL\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // let gCost = closestNode.gCost + 10;\r\n      let gCost = closestNode.gCost + getNewGCost(neighbours[i], closestNode);\r\n\r\n      if (\r\n        open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n        undefined ||\r\n        gCost < neighbours[i].gCost\r\n      ) {\r\n        neighbours[i].previousNode = closestNode;\r\n        neighbours[i].hCost = getManhattanHCost(neighbours[i], endNode);\r\n        neighbours[i].gCost = gCost;\r\n        neighbours[i].distance = neighbours[i].gCost + neighbours[i].hCost;\r\n\r\n        if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n          undefined\r\n        ) {\r\n          open.insert(neighbours[i]);\r\n        } else if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) !==\r\n          undefined\r\n        ) {\r\n          open.changeDistance(neighbours[i], neighbours[i].distance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return closed;\r\n}\r\n\r\nexport function getAvailableNeighbours(node, grid) {\r\n  let neighbours = [];\r\n\r\n  if (node.row - 1 >= 0) neighbours.push(grid[node.row - 1][node.col]);\r\n\r\n  if (node.col + 1 < grid[0].length)\r\n    neighbours.push(grid[node.row][node.col + 1]);\r\n\r\n  if (node.row + 1 < grid.length) neighbours.push(grid[node.row + 1][node.col]);\r\n\r\n  if (node.col - 1 >= 0) neighbours.push(grid[node.row][node.col - 1]);\r\n\r\n  return neighbours;\r\n}\r\n\r\nconst getManhattanHCost = (currentNode, destNode) => {\r\n  const y = Math.abs(currentNode.row - destNode.row);\r\n  const x = Math.abs(currentNode.col - destNode.col);\r\n  return (x + y) * 9.9;\r\n};\r\n\r\nconst getNewGCost = (currentNode, closestNode) => {\r\n  if (closestNode.previousNode === null) {\r\n    return 10;\r\n  }\r\n\r\n  let firstDirection = [\r\n    closestNode.previousNode.row - closestNode.row,\r\n    closestNode.previousNode.col - closestNode.col,\r\n  ];\r\n  let secondDirection = [\r\n    closestNode.row - currentNode.row,\r\n    closestNode.col - currentNode.col,\r\n  ];\r\n\r\n  if (\r\n    firstDirection[0] === secondDirection[0] &&\r\n    firstDirection[1] === secondDirection[1]\r\n  ) {\r\n    return 9;\r\n  } else {\r\n    return 10;\r\n  }\r\n};\r\n\r\nexport const getShortestPath = (startNode, endNode) => {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== startNode) {\r\n    if (currentNode === null || currentNode === undefined) break;\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  shortestPath.push(startNode);\r\n  return shortestPath.reverse();\r\n};","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeDijkstra(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  var t0 = performance.now();\r\n\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = new MinHeap();\r\n  unvisitedNodes = getAllNodesHeap(grid);\r\n  const visitedNodesInOrder = [];\r\n\r\n  visitedNodesInOrder.push(startNode)\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    const closestNode = unvisitedNodes.remove();\r\n    const neighbours = getAvailableNeighboursHeap(closestNode, unvisitedNodes);\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) continue;\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const newDistance = closestNode.distance + 1;\r\n\r\n      unvisitedNodes.changeDistance(neighbours[i], newDistance);\r\n      unvisitedNodes.setPreviousNode(neighbours[i], closestNode);\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED;\r\n    closestNode.closed = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"Dijkstra Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getAllNodesHeap(grid) {\r\n  const nodes = new MinHeap();\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      nodes.insert(grid[row][col]);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getAvailableNeighboursHeap(node, heap) {\r\n  let neighbours = [];\r\n\r\n  const topNeighbour = heap.getNodeAt(`${node.row - 1}:${node.col}`);\r\n  if (topNeighbour !== undefined) neighbours.push(topNeighbour);\r\n\r\n  const rightNeighbour = heap.getNodeAt(`${node.row}:${node.col + 1}`);\r\n  if (rightNeighbour !== undefined) neighbours.push(rightNeighbour);\r\n\r\n  const bottomNeighbour = heap.getNodeAt(`${node.row + 1}:${node.col}`);\r\n  if (bottomNeighbour !== undefined) neighbours.push(bottomNeighbour);\r\n\r\n  const leftNeighbour = heap.getNodeAt(`${node.row}:${node.col - 1}`);\r\n  if (leftNeighbour !== undefined) neighbours.push(leftNeighbour);\r\n\r\n  //   return neighbours.filter(\r\n  //     (neighbour) => neighbour.nodeState === NodeStates.UNVISITED\r\n  //   );\r\n\r\n  return neighbours.filter((neighbour) => neighbour.closed !== true);\r\n}\r\n\r\nexport function getShortestPath(endNode) {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    currentNode.nodeState = NodeStates.SHORTESTPATH;\r\n    shortestPath.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return shortestPath;\r\n}","import React, { Component } from \"react\";\r\nimport \"./path-finding-visualizer.css\";\r\nimport Grid from \"./grid\";\r\nimport NodeStates from \"./node-states\";\r\nimport {\r\n  createGrid,\r\n  replaceGrid,\r\n  clearVisitedNodes,\r\n  clearWallNodes,\r\n} from \"./grid-utilities\";\r\nimport { executeBinaryTree } from '../algorithms/binary-tree'\r\nimport { executeRandom } from '../algorithms/random'\r\nimport { executeAStar, getShortestPath } from \"../algorithms/a-star\";\r\nimport { executeDijkstra } from \"../algorithms/dijkstra\";\r\nimport Dropdown from \"react-bootstrap/Dropdown\";\r\nimport DropdownButton from \"react-bootstrap/Dropdownbutton\";\r\n\r\nexport default class PathFindindVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      selectedAlgo: executeDijkstra,\r\n      selectedAlgoName: \"Dijkstra\",\r\n      selectedMazeAlgo: executeBinaryTree,\r\n      selectedMazeAlgoName: \"Binary Tree\",\r\n      width: 0,\r\n      height: 0,\r\n      isVisualizing: false,\r\n      startNodeIndex: { row: 10, col: 5 },\r\n      endNodeIndex: { row: 10, col: 30 },\r\n      grid: [],\r\n    };\r\n\r\n    this.visitedAnimationTimeout = []\r\n    this.shortestPathTimeout = [];\r\n    this.isMaze = false;\r\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.updateArrayLength();\r\n    window.addEventListener(\"resize\", this.updateWindowDimensions);\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateWindowDimensions);\r\n  }\r\n\r\n  updateWindowDimensions() {\r\n    this.updateArrayLength();\r\n    this.reset();\r\n\r\n    if (this.state.startNodeIndex.row < 0 ||\r\n      this.state.startNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.startNodeIndex.col < 0 ||\r\n      this.state.startNodeIndex.col > this.state.grid[0].length - 1 ||\r\n      this.state.endNodeIndex.row < 0 ||\r\n      this.state.endNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.endNodeIndex.col < 0 ||\r\n      this.state.endNodeIndex.col > this.state.grid[0].length - 1) {\r\n      this.setState({\r\n        startNodeIndex: { row: Math.floor(0), col: Math.floor(0) },\r\n        endNodeIndex: { row: Math.floor(this.rowCount - 1), col: Math.floor(this.colCount - 1) },\r\n      })\r\n    }\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({\r\n      grid: newGrid,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  }\r\n\r\n  updateArrayLength() {\r\n    this.nodeSize = 24;\r\n    this.rowCount = Math.floor(\r\n      (window.innerHeight - window.innerHeight / 5) / this.nodeSize\r\n    );\r\n    this.colCount = Math.floor(\r\n      (window.innerWidth - window.innerWidth / 18) / this.nodeSize\r\n    );\r\n\r\n    if (this.colCount % 2 === 0)\r\n      this.colCount -= 1;\r\n\r\n    if (this.rowCount % 2 === 0)\r\n      this.rowCount -= 1;\r\n\r\n    let root = document.documentElement;\r\n    root.style.setProperty(\"--nodeSize\", this.nodeSize + \"px\");\r\n  }\r\n\r\n  reset() {\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    Array.from(this.shortestPathTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    });\r\n    Array.from(this.visitedAnimationTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    })\r\n\r\n    this.isMaze = false;\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    this.setState({ isVisualizing: false });\r\n  }\r\n\r\n  executePathfinding() {\r\n    if (this.state.isVisualizing) return;\r\n\r\n    const grid = this.state.grid;\r\n    const newGrid = replaceGrid(grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const visitedNodesInOrder = this.state.selectedAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    const shortestPathNodes = getShortestPath(\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.visualize(visitedNodesInOrder, shortestPathNodes);\r\n  }\r\n\r\n  // Visualize visited nodes and shortest path (by calling visualizeShortestPath) on\r\n  visualize = (visitedNodesInOrder, shortestPath) => {\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (visitedNodesInOrder.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        this.shortestPathTimeout.push(setTimeout(() => {\r\n          if (shortestPath !== null) this.visualizeShortestPath(shortestPath);\r\n          return;\r\n        }, 5 * i))\r\n      }\r\n\r\n      const row = visitedNodesInOrder[i].row;\r\n      const col = visitedNodesInOrder[i].col;\r\n\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      this.visitedAnimationTimeout.push(setTimeout(() => {\r\n        visitedNodesInOrder[i].nodeState = NodeStates.VISITED;\r\n        node.className = \"VisitedNode\";\r\n      }, 5 * i))\r\n    }\r\n  }\r\n\r\n  // Visualize shortestPath from array recieved in params\r\n  visualizeShortestPath(shortestPath) {\r\n    const grid = this.state.grid;\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (shortestPath.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const row = shortestPath[i].row;\r\n      const col = shortestPath[i].col;\r\n      grid[row][col] = shortestPath[i];\r\n      const node = document.getElementById(`${row}:${col}`);\r\n\r\n      this.shortestPathTimeout.push(setTimeout(() => {\r\n        if (node !== null) {\r\n          shortestPath[i].nodeState = NodeStates.SHORTESTPATH;\r\n          node.className = \"ShortestPathNode\";\r\n        }\r\n      }, 40 * i))\r\n      toWaitBeforeEnded += 40;\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n  }\r\n\r\n  visualizeMaze() {\r\n    if (this.state.isVisualizing) return;\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const maze = this.state.selectedMazeAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.setState({ isVisualizing: true });\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 1; i < maze.length; i++) {\r\n      const row = maze[i].row;\r\n      const col = maze[i].col;\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      if (this.isMaze) {\r\n        maze[i].nodeState = NodeStates.WALL;\r\n        node.className = \"WallNode\";\r\n      } else {\r\n        this.visitedAnimationTimeout.push(setTimeout(() => {\r\n          maze[i].nodeState = NodeStates.WALL;\r\n          node.className = \"WallNode\";\r\n        }, 3 * i))\r\n        toWaitBeforeEnded += 3;\r\n      }\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n\r\n    this.isMaze = true;\r\n  }\r\n\r\n  updateGrid = (newGrid) => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  updateStartEndIndex = (startNode, endNode) => {\r\n    this.setState({ startNodeIndex: startNode })\r\n    this.setState({ endNodeIndex: endNode });\r\n  };\r\n\r\n  selectAlgorithm = (selectedAlgo) => {\r\n    if (selectedAlgo === \"Dijkstra\") this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    if (selectedAlgo === \"A*\") this.setState({ selectedAlgo: executeAStar, selectedAlgoName: \"A*\" });\r\n    if (selectedAlgo === \"BinaryTree\") this.setState({ selectedMazeAlgo: executeBinaryTree, selectedMazeAlgoName: \"Binary Tree\" })\r\n    if (selectedAlgo === \"Random\") this.setState({ selectedMazeAlgo: executeRandom, selectedMazeAlgoName: \"Random\" })\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div style={{ height: \"100vh\" }} className=\"PathFindingVisualizer\">\r\n        <div className=\"Header\">\r\n          <h1 className=\"TitleText\">Pathfinding Visualizer</h1>\r\n\r\n          <DropdownButton id=\"DropDown\" title=\"Pathfinding Algorithm \">\r\n            <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('Dijkstra')}>Dijkstra's Algorithm</Dropdown.Item>\r\n            <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('A*')} as=\"button\">A* Algorithm</Dropdown.Item>\r\n          </DropdownButton>\r\n\r\n          <button className=\"MainButton\" onClick={() => this.executePathfinding()}>Visualize {this.state.selectedAlgoName}</button>\r\n\r\n          <DropdownButton id=\"DropDown\" title=\"Maze Algorithm \">\r\n            <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"BinaryTree\")} as=\"button\">Binary Tree</Dropdown.Item>\r\n            <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"Random\")} as=\"button\">Random</Dropdown.Item>\r\n          </DropdownButton>\r\n\r\n          <button className=\"MainButton\" onClick={() => this.visualizeMaze()}>{this.state.selectedMazeAlgoName} Maze</button>\r\n\r\n\r\n          <button className=\"SimpleTextButton\" onClick={() => this.reset()}>Reset</button>\r\n          <button className=\"SimpleTextButton\">Help</button>\r\n        </div>\r\n\r\n\r\n        <Grid\r\n          updateGrid={this.updateGrid}\r\n          updateStartEndIndex={this.updateStartEndIndex}\r\n          gridData={this.state.grid}\r\n          startNodeIndex={this.state.startNodeIndex}\r\n          endNodeIndex={this.state.endNodeIndex}\r\n          isVisualizing={(this.state.isVisualizing)}\r\n        />\r\n      </div >\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './path-finding-visualizer/path-finding-visualizer'\r\n\r\nfunction App() {\r\n  return (\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}