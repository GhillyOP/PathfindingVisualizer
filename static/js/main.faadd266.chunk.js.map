{"version":3,"sources":["path-finding-visualizer/node-states.js","path-finding-visualizer/node.jsx","path-finding-visualizer/grid-utilities.js","path-finding-visualizer/grid.jsx","data-structures/min-heap.js","algorithms/a-star.js","algorithms/dijkstra.js","path-finding-visualizer/path-finding-visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["NodeStates","VISITED","UNVISITED","WALL","SHORTESTPATH","Node","props","state","nodeState","isStart","isEnd","nextProps","hasNodeStateChanged","this","isStartChanged","isEndChanged","row","col","onMouseDown","onMouseEnter","onMouseUp","id","onDragStart","preventDragHandler","className","Component","createGrid","rowCount","colCount","startNodeIndex","endNodeIndex","grid","i","j","push","createNode","distance","Infinity","gCost","hCost","closed","previousNode","setNodeInGrid","node","newNode","clearVisitedNodes","length","document","getElementById","Grid","handleMouseDown","isVisusualizing","nextNodeState","gridData","beginDragStart","beginDragEnd","tempGrid","setState","isMouseDown","handleMouseDownIntersect","handleMouseLeave","handleMouseEnter","newGrid","newStartNode","setStartNode","newEndNode","setEndNode","e","preventDefault","updateGrid","updateStartEndIndex","onMouseLeave","handleMouseUp","map","rowI","key","nodeI","isWall","shouldUpdate","renderGrid","MinHeap","heap","Map","heapIndex","get","set","index","element","Math","floor","swap","smallest","delete","pop","sinkDown","left","right","index1","index2","temp","executeAStar","startNode","endNode","t0","performance","now","open","insert","size","closestNode","remove","t1","console","log","neighbours","getAvailableNeighbours","includes","getNewGCost","undefined","getNodeAt","getManhattanHCost","changeDistance","currentNode","destNode","y","abs","firstDirection","secondDirection","executeDijkstra","unvisitedNodes","nodes","getAllNodesHeap","visitedNodesInOrder","getAvailableNeighboursHeap","newDistance","setPreviousNode","topNeighbour","rightNeighbour","bottomNeighbour","leftNeighbour","filter","neighbour","FIRST_START_INDEX","FIRST_END_INDEX","PathFindindVisualizer","selectAlgorithm","selectedAlgo","selectedAlgoName","width","height","updateWindowDimensions","bind","updateArrayLength","window","addEventListener","removeEventListener","innerWidth","innerHeight","nodeSize","documentElement","style","setProperty","clearTimeout","visitedAnimationTimeout","shortestPathTimeout","replaceGrid","shortestPathNodes","shortestPath","reverse","getShortestPath","visualize","setTimeout","visualizeShortestPath","DropdownButton","title","Dropdown","Item","onClick","as","executePathfinding","reset","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"iWAOeA,G,YAPI,CACfC,QAAS,UACTC,UAAW,YACXC,KAAM,OACNC,aAAc,iBCAGC,E,YACnB,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KACDC,MAAQ,CACXC,UAAWR,EAAWE,UACtBO,SAAS,EACTC,OAAO,GALQ,E,mFAUGC,GACpB,IAAMC,EAAsBC,KAAKP,MAAME,YAAcG,EAAUH,UACzDM,EAAiBD,KAAKP,MAAMG,UAAYE,EAAUF,QAClDM,EAAeF,KAAKP,MAAMI,QAAUC,EAAUD,MAEpD,OAAOE,GAAuBE,GAAkBC,I,+BAYxC,IAAD,EACoDF,KAAKP,MAAxDU,EADD,EACCA,IAAKC,EADN,EACMA,IAAKC,EADX,EACWA,YAAaC,EADxB,EACwBA,aAAcC,EADtC,EACsCA,UAE7C,OAAIP,KAAKP,MAAMG,QAEX,yBACEY,GAAE,UAAKL,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBI,YAAaT,KAAKU,mBAClBC,UAAU,cAGLX,KAAKP,MAAMI,MAElB,yBACEW,GAAE,UAAKL,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBI,YAAaT,KAAKU,mBAClBC,UAAU,YAGLX,KAAKN,MAAMC,YAAcR,EAAWG,KAE3C,yBACEkB,GAAE,UAAKL,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBI,YAAaT,KAAKU,mBAClBC,UAAU,aAGLX,KAAKN,MAAMC,YAAcR,EAAWE,UAE3C,yBACEmB,GAAE,UAAKL,EAAL,YAAYC,GACdC,YAAa,kBAAMA,EAAYF,EAAKC,IACpCG,UAAW,kBAAMA,KACjBD,aAAc,kBAAMA,EAAaH,EAAKC,IACtCK,YAAaT,KAAKU,mBAClBC,UAAU,SAGLX,KAAKN,MAAMC,YAAcR,EAAWC,QAE3C,yBACEoB,GAAE,UAAKL,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBC,aAAc,kBAAMA,EAAaH,EAAKC,IACtCK,YAAaT,KAAKU,mBAClBC,UAAU,gBAGLX,KAAKN,MAAMC,YAAcR,EAAWI,aAE3C,yBACEiB,GAAE,UAAKL,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBC,aAAc,kBAAMA,EAAaH,EAAKC,IACtCK,YAAaT,KAAKU,mBAClBC,UAAU,qBAIP,iD,gDA3EqBb,GAC9B,MAAO,CACLH,UAAWG,EAAUH,UACrBC,QAASE,EAAUF,QACnBC,MAAOC,EAAUD,W,GAxBWe,a,QCFrBC,EAAa,SACxBC,EACAC,EACAC,EACAC,GAGA,IADA,IAAIC,EAAO,GACFC,EAAI,EAAGA,EAAIL,EAAUK,IAAK,CAGjC,IAFA,IAAIhB,EAAM,GAEDiB,EAAI,EAAGA,EAAIL,EAAUK,IAC5BjB,EAAIkB,KAAKC,EAAWH,EAAGC,EAAGJ,EAAgBC,IAE5CC,EAAKG,KAAKlB,GAEZ,OAAOe,GAGII,EAAa,SAACnB,EAAKC,EAAKY,EAAgBC,GACnD,IAAIrB,GAAU,EACVC,GAAQ,EAKZ,OAHIM,IAAQa,EAAeb,KAAOC,IAAQY,EAAeZ,IAAKR,GAAU,EAC/DO,IAAQc,EAAad,KAAOC,IAAQa,EAAab,MAAKP,GAAQ,GAEhE,CACLM,MACAC,MACAR,QAASA,EACTC,MAAOA,EACP0B,SAAUC,IACVC,MAAO,EACPC,MAAO,EACPC,QAAQ,EACRC,aAAc,KACdjC,UAAWR,EAAWE,YAIbwC,EAAgB,SAACX,EAAMf,EAAKC,EAAKT,GAC5C,IAAMmC,EAAOZ,EAAKf,GAAKC,GAEjB2B,EAAO,eACRD,EADQ,CAEXnC,UAAWA,IAGb,OADAuB,EAAKf,GAAKC,GAAO2B,EACVb,GA2DIc,EAAoB,SAACd,EAAMF,EAAgBC,GACtD,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKe,OAAQd,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGe,OAAQb,IAAK,CACvC,IAAMU,EAAOI,SAASC,eAAT,UAA2BhB,EAA3B,YAAgCC,IAEzCD,IAAMH,EAAeb,KAAOiB,IAAMJ,EAAeZ,IAIjDe,IAAMF,EAAad,KAAOiB,IAAMH,EAAab,IAI7Cc,EAAKC,GAAGC,GAAGzB,YAAcR,EAAWG,OAGtCwC,EAAKnB,UAAY,QANjBmB,EAAKnB,UAAY,UAJjBmB,EAAKnB,UAAY,cCrGJyB,E,YACnB,WAAY3C,GAAQ,IAAD,8BACjB,4CAAMA,KAMR4C,gBAAkB,SAAClC,EAAKC,GACtB,IAAI,EAAKkC,gBAAT,CAGA,IAAIC,EAAgBpD,EAAWG,KAC3B,EAAKG,MAAM+C,SAASrC,GAAKC,GAAKT,YAAcR,EAAWG,OACzDiD,EAAgBpD,EAAWE,WAIzB,EAAKI,MAAM+C,SAASrC,GAAKC,GAAKR,QAChC,EAAK6C,gBAAiB,EAKpB,EAAKhD,MAAM+C,SAASrC,GAAKC,GAAKP,MAChC,EAAK6C,cAAe,GAKtB,EAAKC,SAAWd,EAAc,EAAKpC,MAAM+C,SAAUrC,EAAKC,EAAKmC,GAC7D,EAAKK,SAAS,CAAEC,aAAa,OA9BZ,EAiCnBC,yBAA2B,WACrB,EAAKR,kBACT,EAAKK,SAAW,EAAKlD,MAAM+C,SAC3B,EAAKI,SAAS,CAAEC,aAAa,MApCZ,EAuCnBE,iBAAmB,WACb,EAAKT,iBACT,EAAKM,SAAS,CAAEC,aAAa,KAzCZ,EA6DnBG,iBAAmB,SAAC7C,EAAKC,GACvB,IAAI,EAAKkC,iBACJ,EAAK5C,MAAMmD,YAAhB,CAEA,IAAMf,EAAOI,SAASC,eAAT,UAA2BhC,EAA3B,YAAkCC,IACzCc,EAAO,EAAKyB,SAElB,OAAI,EAAKF,gBACPX,EAAKnB,UAAY,iBACjB,EAAKgC,SDhCiB,SAACzB,EAAMf,EAAKC,EAAKY,GAC3C,IAAMiC,EAAU/B,EACVY,EAAOmB,EAAQ9C,GAAKC,GAEpB8C,EAAY,eACbpB,EADa,CAEhBlC,SAAS,IAYX,OATAqD,EAAQ9C,GAAKC,GAAO8C,EACpBD,EAAQjC,EAAeb,KAAKa,EAAeZ,KAAKR,SAAU,EAC1DsC,SAASC,eAAT,UACKnB,EAAeb,IADpB,YAC2Ba,EAAeZ,MACxCO,UAAY,OAEdK,EAAeb,IAAMA,EACrBa,EAAeZ,IAAMA,EAEd6C,ECcaE,CACd,EAAK1D,MAAM+C,SACXrC,EACAC,EACA,EAAKX,MAAMuB,kBAGJ,EAAK0B,cACdZ,EAAKnB,UAAY,eACjB,EAAKgC,SDpBe,SAACzB,EAAMf,EAAKC,EAAKa,GACzC,IAAMgC,EAAU/B,EACVY,EAAOmB,EAAQ9C,GAAKC,GAEpBgD,EAAU,eACXtB,EADW,CAEdjC,OAAO,IAWT,OARAoD,EAAQ9C,GAAKC,GAAOgD,EACpBH,EAAQhC,EAAad,KAAKc,EAAab,KAAKP,OAAQ,EACpDqC,SAASC,eAAT,UAA2BlB,EAAad,IAAxC,YAA+Cc,EAAab,MAAOO,UACjE,OAEFM,EAAad,IAAMA,EACnBc,EAAab,IAAMA,EAEZ6C,ECGaI,CACd,EAAK5D,MAAM+C,SACXrC,EACAC,EACA,EAAKX,MAAMwB,qBAGJ,EAAKvB,MAAMmD,cACpBf,EAAKnB,UAAY,WACjB,EAAKgC,SAAWd,EAAcX,EAAMf,EAAKC,EAAKjB,EAAWG,UAxF1C,EA4FnBoB,mBAAqB,SAAC4C,GACpBA,EAAEC,kBA3FF,EAAK7D,MAAQ,CACXmD,aAAa,GAHE,E,6EA6Cb7C,KAAKsC,iBACJtC,KAAKN,MAAMmD,cAEZ7C,KAAKyC,eAAgBzC,KAAKyC,gBAAiB,EACtCzC,KAAK0C,eAAc1C,KAAK0C,cAAe,GAGhD1C,KAAK4C,SAAS,CAAEC,aAAa,IAE7B7C,KAAKP,MAAM+D,WAAWxD,KAAK2C,UAC3B3C,KAAKP,MAAMgE,oBACTzD,KAAKP,MAAMuB,eACXhB,KAAKP,MAAMwB,iB,mCAuCD,IAAD,OACX,OACE,yBAAKN,UAAU,iBACb,yBACEA,UAAU,OACVF,YAAaT,KAAKU,mBAClBgD,aAAc1D,KAAK+C,iBACnBxC,UAAW,kBAAM,EAAKoD,iBACtBtD,YAAa,kBAAM,EAAKyC,6BAEvB9C,KAAKP,MAAM+C,SAASoB,KAAI,SAACzD,EAAK0D,GAC7B,OACE,yBAAKC,IAAKD,GACP1D,EAAIyD,KAAI,SAAC9B,EAAMiC,GAAP,OACP,kBAAC,EAAD,CACE3D,IAAK0B,EAAK1B,IACVD,IAAK2B,EAAK3B,IACVP,QAASkC,EAAKlC,QACdC,MAAOiC,EAAKjC,MACZmE,OAAQlC,EAAKkC,OACbC,aAAcnC,EAAKmC,aACnBtE,UAAWmC,EAAKnC,UAChBgC,OAAQG,EAAKH,OACbpB,UAAW,kBAAM,EAAKoD,iBACtBtD,YAAa,kBAAM,EAAKgC,gBAAgBP,EAAK3B,IAAK2B,EAAK1B,MACvDE,aAAc,kBAAM,EAAK0C,iBAAiBlB,EAAK3B,IAAK2B,EAAK1B,MACzDsD,aAAc,kBACZ,EAAKX,iBAAiBjB,EAAM3B,EAAK2B,EAAK1B,MAExCK,YAAa,EAAKC,mBAClBoD,IAAG,UAAKhC,EAAK3B,IAAV,YAAiB2B,EAAK1B,kB,+BAazC,OAAOJ,KAAKkE,iB,GA5IkBtD,aCRbuD,E,WACjB,aAAe,oBACXnE,KAAKoE,KAAO,GACZpE,KAAK4D,IAAM,IAAIS,I,qDAIf,OAAOrE,KAAKoE,KAAK,K,gCAGXN,GACN,IAAMQ,EAAYtE,KAAK4D,IAAIW,IAAIT,GAE/B,OADa9D,KAAKoE,KAAKE,K,+BAOvB,IAAK,IAAInD,EAAI,EAAGA,IAAMnB,KAAKoE,KAAKnC,OAAS,GAAK,EAAGd,IAAK,CAElD,GAAInB,KAAKoE,KAAK,EAAIjD,EAAI,GAAKnB,KAAKoE,KAAKjD,GACjC,OAAO,EAGX,GAAI,EAAIA,EAAI,EAAInB,KAAKoE,KAAKnC,QAAUjC,KAAKoE,KAAK,EAAIjD,EAAI,GAAKnB,KAAKoE,KAAKjD,GACjE,OAAO,EAEf,OAAO,I,6BAIJW,GACH9B,KAAKoE,KAAK/C,KAAKS,GACf9B,KAAK4D,IAAIY,IAAT,UAAgB1C,EAAK3B,IAArB,YAA4B2B,EAAK1B,KAAO0B,GAIxC,IAFA,IAAI2C,EAAQzE,KAAKoE,KAAKnC,OAAS,EAExBwC,EAAQ,GAAG,CACd,IAAIC,EAAU1E,KAAKoE,KAAKK,GAGxB,GAFazE,KAAKoE,KAAKO,KAAKC,OAAOH,EAAQ,GAAK,IAErClD,SAAWmD,EAAQnD,SAAU,MAGxCvB,KAAK6E,KAAKJ,EAAOE,KAAKC,OAAOH,EAAQ,GAAK,IAC1CA,EAAQE,KAAKC,OAAOH,EAAQ,GAAK,M,+BAKrC,IAAIK,EAAW9E,KAAKoE,KAAK,GAIzB,OAHApE,KAAK4D,IAAImB,OAAT,UAAmBD,EAAS3E,IAA5B,YAAmC2E,EAAS1E,MAC5CJ,KAAKoE,KAAK,GAAKpE,KAAKoE,KAAKY,MACzBhF,KAAKiF,SAAS,GACPH,I,+BAGFL,GACL,IAAIS,EAAO,EAAIT,EAAQ,EACnBU,EAAQ,EAAIV,EAAQ,EACpBK,EAAWL,EACTxC,EAASjC,KAAKoE,KAAKnC,OAIrBiD,EAAOjD,GACPjC,KAAKoE,KAAKc,GAAM3D,SAAWvB,KAAKoE,KAAKU,GAAUvD,WAE/CuD,EAAWI,GAIXC,EAAQlD,GACRjC,KAAKoE,KAAKe,GAAO5D,SAAWvB,KAAKoE,KAAKU,GAAUvD,WAEhDuD,EAAWK,GAGXL,IAAaL,IACbzE,KAAK6E,KAAKJ,EAAOK,GACjB9E,KAAKiF,SAASH,M,qCAIPhD,EAAMP,GAEjB,IAAI+C,EAAYtE,KAAK4D,IAAIW,IAAT,UAAgBzC,EAAK3B,IAArB,YAA4B2B,EAAK1B,MAKjD,IAHAJ,KAAKoE,KAAKE,GAAW/C,SAAWA,EAGX,IAAd+C,GAAmBtE,KAAKoE,KAAKE,GAAW/C,SAAWvB,KAAKoE,KAAKO,KAAKC,OAAON,EAAY,GAAK,IAAI/C,UACjGvB,KAAK6E,KAAKP,EAAWK,KAAKC,OAAON,EAAY,GAAK,IAClDA,EAAYK,KAAKC,OAAON,EAAY,GAAK,K,sCAIjCxC,EAAMF,GAClB,IAAI0C,EAAYtE,KAAK4D,IAAIW,IAAT,UAAgBzC,EAAK3B,IAArB,YAA4B2B,EAAK1B,MACjDJ,KAAKoE,KAAKE,GAAW1C,aAAeA,I,2BAInCwD,EAAQC,GACT,IAAMC,EAAOtF,KAAKoE,KAAKgB,GACvBpF,KAAKoE,KAAKgB,GAAUpF,KAAKoE,KAAKiB,GAC9BrF,KAAKoE,KAAKiB,GAAUC,EAEpBtF,KAAK4D,IAAIY,IAAT,UAAgBxE,KAAKoE,KAAKgB,GAAQjF,IAAlC,YAAyCH,KAAKoE,KAAKgB,GAAQhF,KAAOgF,GAClEpF,KAAK4D,IAAIY,IAAT,UAAgBxE,KAAKoE,KAAKiB,GAAQlF,IAAlC,YAAyCH,KAAKoE,KAAKiB,GAAQjF,KAAOiF,O,KChHnE,SAASE,EAAarE,EAAMsE,EAAWC,GAC5C,IAAK,IAAItE,EAAI,EAAGA,EAAID,EAAKe,OAAQd,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGe,OAAQb,IAClCF,EAAKC,GAAGC,GAAGG,SAAW,EAI1B,IAAImE,EAAKC,YAAYC,MAGrBJ,EAAUjE,SAAW,EACrB,IAAIsE,EAAO,IAAI1B,EACXxC,EAAS,GAMb,IAHAkE,EAAKC,OAAON,GAGLK,EAAKjC,IAAImC,KAAO,GAAG,CAExB,IAAIC,EAAcH,EAAKI,SAGvB,GAFAtE,EAAON,KAAK2E,GAERA,IAAgBP,EAAS,CAC3B,IAAIS,EAAKP,YAAYC,MAErB,OADAO,QAAQC,IAAI,eAAiBF,EAAKR,GAAM,kBACjC/D,EAGT,GAAIqE,EAAYrG,YAAcR,EAAWG,KAAzC,CAIA,GAAI0G,EAAYzE,WAAaC,IAE3B,OADA2E,QAAQC,IAAI,WACLzE,EAMT,IADA,IAAM0E,EAAaC,EAAuBN,EAAa9E,GAC9CC,EAAI,EAAGA,EAAIkF,EAAWpE,OAAQd,IACrC,IACEQ,EAAO4E,SAASF,EAAWlF,KAC3BkF,EAAWlF,GAAGxB,YAAcR,EAAWG,KAFzC,CAQA,IAAImC,EAAQuE,EAAYvE,MAAQ+E,EAAYH,EAAWlF,GAAI6E,SAIvDS,IADFZ,EAAKa,UAAL,UAAkBL,EAAWlF,GAAGhB,IAAhC,YAAuCkG,EAAWlF,GAAGf,OAErDqB,EAAQ4E,EAAWlF,GAAGM,SAEtB4E,EAAWlF,GAAGS,aAAeoE,EAC7BK,EAAWlF,GAAGO,MAAQiF,EAAkBN,EAAWlF,GAAIsE,GACvDY,EAAWlF,GAAGM,MAAQA,EACtB4E,EAAWlF,GAAGI,SAAW8E,EAAWlF,GAAGM,MAAQ4E,EAAWlF,GAAGO,WAI3D+E,IADAZ,EAAKa,UAAL,UAAkBL,EAAWlF,GAAGhB,IAAhC,YAAuCkG,EAAWlF,GAAGf,MAGrDyF,EAAKC,OAAOO,EAAWlF,SAGvBsF,IADAZ,EAAKa,UAAL,UAAkBL,EAAWlF,GAAGhB,IAAhC,YAAuCkG,EAAWlF,GAAGf,OAGrDyF,EAAKe,eAAeP,EAAWlF,GAAIkF,EAAWlF,GAAGI,aAKzD,OAAOI,EAGF,SAAS2E,EAAuBxE,EAAMZ,GAC3C,IAAImF,EAAa,GAWjB,OATIvE,EAAK3B,IAAM,GAAK,GAAGkG,EAAWhF,KAAKH,EAAKY,EAAK3B,IAAM,GAAG2B,EAAK1B,MAE3D0B,EAAK1B,IAAM,EAAIc,EAAK,GAAGe,QACzBoE,EAAWhF,KAAKH,EAAKY,EAAK3B,KAAK2B,EAAK1B,IAAM,IAExC0B,EAAK3B,IAAM,EAAIe,EAAKe,QAAQoE,EAAWhF,KAAKH,EAAKY,EAAK3B,IAAM,GAAG2B,EAAK1B,MAEpE0B,EAAK1B,IAAM,GAAK,GAAGiG,EAAWhF,KAAKH,EAAKY,EAAK3B,KAAK2B,EAAK1B,IAAM,IAE1DiG,EAGT,IAAMM,EAAoB,SAACE,EAAaC,GACtC,IAAMC,EAAIpC,KAAKqC,IAAIH,EAAY1G,IAAM2G,EAAS3G,KAE9C,OAAiB,KADPwE,KAAKqC,IAAIH,EAAYzG,IAAM0G,EAAS1G,KAClC2G,IAGRP,EAAc,SAACK,EAAab,GAChC,GAAiC,OAA7BA,EAAYpE,aACd,OAAO,GAGT,IAAIqF,EAAiB,CACnBjB,EAAYpE,aAAazB,IAAM6F,EAAY7F,IAC3C6F,EAAYpE,aAAaxB,IAAM4F,EAAY5F,KAEzC8G,EAAkB,CACpBlB,EAAY7F,IAAM0G,EAAY1G,IAC9B6F,EAAY5F,IAAMyG,EAAYzG,KAGhC,OACE6G,EAAe,KAAOC,EAAgB,IACtCD,EAAe,KAAOC,EAAgB,GAE/B,EAEA,ICxHJ,SAASC,EAAgBjG,EAAMsE,EAAWC,GAC/C,IAAIC,EAAKC,YAAYC,MAErBJ,EAAUjE,SAAW,EACrB,IAAI6F,EAAiB,IAAIjD,EACzBiD,EAiCK,SAAyBlG,GAE9B,IADA,IAAMmG,EAAQ,IAAIlD,EACThE,EAAM,EAAGA,EAAMe,EAAKe,OAAQ9B,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMc,EAAK,GAAGe,OAAQ7B,IACtCiH,EAAMvB,OAAO5E,EAAKf,GAAKC,IAG3B,OAAOiH,EAxCUC,CAAgBpG,GAGjC,IAFA,IAAMqG,EAAsB,GAEK,IAA1BH,EAAenF,QAAc,CAClC,IAAM+D,EAAcoB,EAAenB,SAC7BI,EAAamB,EAA2BxB,EAAaoB,GAE3D,GAAIpB,EAAYrG,YAAcR,EAAWG,KAAzC,CACA,GAAI0G,EAAYzE,WAAaC,IAE3B,OADA2E,QAAQC,IAAI,WACLmB,EAGT,IAAK,IAAIpG,EAAI,EAAGA,EAAIkF,EAAWpE,OAAQd,IAAK,CAC1C,IAAMsG,EAAczB,EAAYzE,SAAW,EAE3C6F,EAAeR,eAAeP,EAAWlF,GAAIsG,GAC7CL,EAAeM,gBAAgBrB,EAAWlF,GAAI6E,GAQhD,GAJAA,EAAYrE,QAAS,EAErB4F,EAAoBlG,KAAK2E,GAErBA,IAAgBP,EAAS,CAC3B,IAAIS,EAAKP,YAAYC,MAErB,OADAO,QAAQC,IAAI,kBAAoBF,EAAKR,GAAM,kBACpC6B,KAeN,SAASC,EAA2B1F,EAAMsC,GAC/C,IAAIiC,EAAa,GAEXsB,EAAevD,EAAKsC,UAAL,UAAkB5E,EAAK3B,IAAM,EAA7B,YAAkC2B,EAAK1B,WACvCqG,IAAjBkB,GAA4BtB,EAAWhF,KAAKsG,GAEhD,IAAMC,EAAiBxD,EAAKsC,UAAL,UAAkB5E,EAAK3B,IAAvB,YAA8B2B,EAAK1B,IAAM,SACzCqG,IAAnBmB,GAA8BvB,EAAWhF,KAAKuG,GAElD,IAAMC,EAAkBzD,EAAKsC,UAAL,UAAkB5E,EAAK3B,IAAM,EAA7B,YAAkC2B,EAAK1B,WACvCqG,IAApBoB,GAA+BxB,EAAWhF,KAAKwG,GAEnD,IAAMC,EAAgB1D,EAAKsC,UAAL,UAAkB5E,EAAK3B,IAAvB,YAA8B2B,EAAK1B,IAAM,IAO/D,YANsBqG,IAAlBqB,GAA6BzB,EAAWhF,KAAKyG,GAM1CzB,EAAW0B,QAAO,SAACC,GAAD,OAAoC,IAArBA,EAAUrG,U,mBCxDhDsG,EAAoB,CAAC,GAAI,GACzBC,EAAkB,CAAC,GAAI,IAENC,E,YACnB,WAAY1I,GAAQ,IAAD,8BACjB,4CAAMA,KA+JR+D,WAAa,SAACP,GACZ,EAAKL,SAAS,CAAE1B,KAAM+B,KAjKL,EAoKnBQ,oBAAsB,SAAC+B,EAAWC,GAChC,EAAKzE,eAAiBwE,EACtB,EAAKvE,aAAewE,GAtKH,EAyKnB2C,gBAAkB,SAACC,GACI,aAAjBA,GAA8B,EAAKzF,SAAS,CAACyF,aAAclB,EAAiBmB,iBAAkB,aAG7E,OAAjBD,GAAwB,EAAKzF,SAAS,CAACyF,aAAc9C,EAAc+C,iBAAkB,QA3KzF,EAAK5I,MAAQ,CACX2I,aAAclB,EACdmB,iBAAkB,WAClBC,MAAO,EACPC,OAAQ,EACRtH,KAAM,IAGR,EAAKF,eAAiB,CACpBb,IAAK8H,EAAkB,GACvB7H,IAAK6H,EAAkB,IAGzB,EAAKhH,aAAe,CAClBd,IAAK+H,EAAgB,GACrB9H,IAAK8H,EAAgB,IAGvB,EAAKO,uBAAyB,EAAKA,uBAAuBC,KAA5B,gBApBb,E,iFAwBjB1I,KAAK2I,oBACLC,OAAOC,iBAAiB,SAAU7I,KAAKyI,wBACvC,IAAMxF,EAAUpC,EACdb,KAAKc,SACLd,KAAKe,SACLf,KAAKgB,eACLhB,KAAKiB,cAEPjB,KAAK4C,SAAS,CAACyF,aAAclB,EAAiBmB,iBAAkB,aAChEtI,KAAK4C,SAAS,CAAE1B,KAAM+B,M,6CAItB2F,OAAOE,oBAAoB,SAAU9I,KAAKyI,0B,+CAI1CzI,KAAK2I,oBACL,IAAM1F,EAAUpC,EACdb,KAAKc,SACLd,KAAKe,SACLf,KAAKgB,eACLhB,KAAKiB,cAEPjB,KAAK4C,SAAS,CACZ1B,KAAM+B,EACNsF,MAAOK,OAAOG,WACdP,OAAQI,OAAOI,gB,0CAKjBhJ,KAAKiJ,SAAW,GAChBjJ,KAAKc,SAAW6D,KAAKC,OAClBgE,OAAOI,YAAcJ,OAAOI,YAAc,GAAKhJ,KAAKiJ,UAEvDjJ,KAAKe,SAAW4D,KAAKC,OAClBgE,OAAOG,WAAaH,OAAOG,WAAa,IAAM/I,KAAKiJ,UAG3C/G,SAASgH,gBACfC,MAAMC,YAAY,aAAcpJ,KAAKiJ,SAAW,Q,8BAIrD,IAAMhG,EAAUpC,EACdb,KAAKc,SACLd,KAAKe,SACLf,KAAKgB,eACLhB,KAAKiB,cAEPjB,KAAK4C,SAAS,CAAE1B,KAAM+B,IACtBjB,EAAkBhC,KAAKN,MAAMwB,KAAMlB,KAAKgB,eAAgBhB,KAAKiB,cAC7DjB,KAAKsC,iBAAkB,EACvB+G,aAAarJ,KAAKsJ,yBAClBD,aAAarJ,KAAKuJ,uB,2CAIlB,IAAIvJ,KAAKsC,gBAAT,CAEA,IACMW,ELXiB,SAAC/B,EAAMF,EAAgBC,GAChD,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKe,OAAQd,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGe,OAAQb,IAC9BF,EAAKC,GAAGC,GAAGzB,YAAcR,EAAWG,MACtC4B,EAAKC,GAAGC,GAAKE,EAAWH,EAAGC,EAAGJ,EAAgBC,GAC9CC,EAAKC,GAAGC,GAAGzB,UAAYR,EAAWG,KAClC4B,EAAKC,GAAGC,GAAGO,QAAS,GAEpBT,EAAKC,GAAGC,GAAKE,EAAWH,EAAGC,EAAGJ,EAAgBC,GAIpD,OAAOC,EKDWsI,CADHxJ,KAAKN,MAAMwB,KACUlB,KAAKgB,eAAgBhB,KAAKiB,cAE5De,EAAkBiB,EAASjD,KAAKgB,eAAgBhB,KAAKiB,cAErD,IAAMsG,EAAsBvH,KAAKN,MAAM2I,aACrCpF,EACAA,EAAQjD,KAAKgB,eAAeb,KAAKH,KAAKgB,eAAeZ,KACrD6C,EAAQjD,KAAKiB,aAAad,KAAKH,KAAKiB,aAAab,MAG7CqJ,EFaqB,SAACjE,EAAWC,GAGzC,IAFA,IAAMiE,EAAe,GACjB7C,EAAcpB,EACXoB,IAAgBrB,GACD,OAAhBqB,QAAwCJ,IAAhBI,GAE5B6C,EAAarI,KAAKwF,GAClBA,EAAcA,EAAYjF,aAG5B,OADA8H,EAAarI,KAAKmE,GACXkE,EAAaC,UEvBQC,CACxB3G,EAAQjD,KAAKgB,eAAeb,KAAKH,KAAKgB,eAAeZ,KACrD6C,EAAQjD,KAAKiB,aAAad,KAAKH,KAAKiB,aAAab,MAGnDJ,KAAK6J,UAAUtC,EAAqBkC,M,gCAI5BlC,EAAqBmC,GAAe,IAAD,OAG3C,GAFA1J,KAAKsC,iBAAkB,EAEY,IAA/BiF,EAAoBtF,OAKxB,IAR2C,eAQlCd,GACHA,IAAMoG,EAAoBtF,OAAS,IACrC,EAAKsH,oBAAsBO,YAAW,WACf,OAAjBJ,GAAuB,EAAKK,sBAAsBL,KAErD,EAAIvI,IAGT,IAAMhB,EAAMoH,EAAoBpG,GAAGhB,IAC7BC,EAAMmH,EAAoBpG,GAAGf,IAE7B0B,EAAOI,SAASC,eAAT,UAA2BhC,EAA3B,YAAkCC,IAC/C,EAAKkJ,wBAA0BQ,YAAW,WACxCvC,EAAoBpG,GAAGxB,UAAYR,EAAWC,QAC9C0C,EAAKnB,UAAY,gBAChB,EAAIQ,IAfAA,EAAI,EAAGA,EAAIoG,EAAoBtF,OAAQd,IAAM,EAA7CA,QAJPnB,KAAKsC,iBAAkB,I,4CAwBLoH,GAAe,IAAD,OAC5BxI,EAAOlB,KAAKN,MAAMwB,KAGxB,GAFAlB,KAAKsC,iBAAkB,EAEK,IAAxBoH,EAAazH,OAKjB,IATkC,eASzBd,GACP,IAAMhB,EAAMuJ,EAAavI,GAAGhB,IACtBC,EAAMsJ,EAAavI,GAAGf,IAC5Bc,EAAKf,GAAKC,GAAOsJ,EAAavI,GAC9B,IAAMW,EAAOI,SAASC,eAAT,UAA2BhC,EAA3B,YAAkCC,IAE/C0J,YAAW,WACI,OAAThI,IACF4H,EAAavI,GAAGxB,UAAYR,EAAWI,aACvCuC,EAAKnB,UAAY,oBAEfQ,IAAMuI,EAAazH,OAAS,IAC9B,EAAKK,iBAAkB,KAExB,GAAKnB,IAdDA,EAAI,EAAGA,EAAIuI,EAAazH,OAAQd,IAAM,EAAtCA,QAJPnB,KAAKsC,iBAAkB,I,+BAuCjB,IAAD,OAEP,OACE,yBAAK6G,MAAS,CAACX,OAAO,SAAU7H,UAAU,yBACxC,yBAAKA,UAAU,UACb,yBAAKA,UAAU,kBACb,wBAAIA,UAAU,aAAd,2BAEF,yBAAKA,UAAU,qBACb,kBAACqJ,EAAA,EAAD,CAAgBxJ,GAAG,WAAWyJ,MAAM,eAChC,kBAACC,EAAA,EAASC,KAAV,CAAe3J,GAAG,WAAW4J,QAAS,kBAAK,EAAKhC,gBAAgB,cAAhE,wBACA,kBAAC8B,EAAA,EAASC,KAAV,CAAe3J,GAAG,WAAW4J,QAAS,kBAAK,EAAKhC,gBAAgB,OAAOiC,GAAG,UAA1E,iBAQJ,4BAAQ1J,UAAU,kBAAkByJ,QAAS,kBAAM,EAAKE,uBAAxD,aAA0FtK,KAAKN,MAAM4I,kBACrG,4BAAQ3H,UAAU,cAAcyJ,QAAS,kBAAM,EAAKG,UAApD,WAKJ,kBAAC,EAAD,CACE/G,WAAYxD,KAAKwD,WACjBC,oBAAqBzD,KAAKyD,oBAC1BjB,SAAUxC,KAAKN,MAAMwB,KACrBF,eAAgBhB,KAAKgB,eACrBC,aAAcjB,KAAKiB,oB,GAhNsBL,aCPpC4J,MANf,WACE,OACI,kBAAC,EAAD,OCMcC,QACW,cAA7B7B,OAAO8B,SAASC,UAEe,UAA7B/B,OAAO8B,SAASC,UAEhB/B,OAAO8B,SAASC,SAASC,MACvB,2D,MCVNC,IAASC,OAAO,kBAAC,EAAD,MAAS5I,SAASC,eAAe,SD2H3C,kBAAmB4I,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.faadd266.chunk.js","sourcesContent":["const NodeStates = {\r\n    VISITED: \"visited\",\r\n    UNVISITED: \"unvisited\",\r\n    WALL: \"wall\",\r\n    SHORTESTPATH: 'shortestPath'\r\n  };\r\n\r\nexport default NodeStates;\r\n","import React, { Component } from \"react\";\r\nimport \"./grid.css\";\r\nimport NodeStates from \"./node-states\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodeState: NodeStates.UNVISITED,\r\n      isStart: false,\r\n      isEnd: false\r\n    };\r\n  }\r\n\r\n  /** Make sure not all nodes update every time the grid renders */\r\n  shouldComponentUpdate(nextProps) {\r\n    const hasNodeStateChanged = this.props.nodeState !== nextProps.nodeState;\r\n    const isStartChanged = this.props.isStart !== nextProps.isStart;\r\n    const isEndChanged = this.props.isEnd !== nextProps.isEnd;\r\n\r\n    return hasNodeStateChanged || isStartChanged || isEndChanged;\r\n  }\r\n\r\n  /** Change State based on property nodeState */\r\n  static getDerivedStateFromProps(nextProps) {\r\n    return {\r\n      nodeState: nextProps.nodeState,\r\n      isStart: nextProps.isStart,\r\n      isEnd: nextProps.isEnd\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { row, col, onMouseDown, onMouseEnter, onMouseUp } = this.props;\r\n\r\n    if (this.props.isStart) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"StartNode\"\r\n        ></div>\r\n      );\r\n    } else if (this.props.isEnd) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"EndNode\"\r\n        ></div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.WALL) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"WallNode\"\r\n        ></div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.UNVISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        ></div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.VISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"VisitedNode\"\r\n        ></div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.SHORTESTPATH) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"ShortestPathNode\"\r\n        ></div>\r\n      );\r\n    } else {\r\n      return <div>no such state</div>;\r\n    }\r\n  }\r\n}\r\n","import NodeStates from \"./node-states\";\r\n\r\nexport const createGrid = (\r\n  rowCount,\r\n  colCount,\r\n  startNodeIndex,\r\n  endNodeIndex\r\n) => {\r\n  let grid = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let row = [];\r\n\r\n    for (let j = 0; j < colCount; j++) {\r\n      row.push(createNode(i, j, startNodeIndex, endNodeIndex));\r\n    }\r\n    grid.push(row);\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const createNode = (row, col, startNodeIndex, endNodeIndex) => {\r\n  let isStart = false;\r\n  let isEnd = false;\r\n\r\n  if (row === startNodeIndex.row && col === startNodeIndex.col) isStart = true;\r\n  else if (row === endNodeIndex.row && col === endNodeIndex.col) isEnd = true;\r\n\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: isStart,\r\n    isEnd: isEnd,\r\n    distance: Infinity,\r\n    gCost: 0,\r\n    hCost: 0,\r\n    closed: false,\r\n    previousNode: null,\r\n    nodeState: NodeStates.UNVISITED,\r\n  };\r\n};\r\n\r\nexport const setNodeInGrid = (grid, row, col, nodeState) => {\r\n  const node = grid[row][col];\r\n\r\n  const newNode = {\r\n    ...node,\r\n    nodeState: nodeState,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nexport const setStartNode = (grid, row, col, startNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const newStartNode = {\r\n    ...node,\r\n    isStart: true,\r\n  };\r\n\r\n  newGrid[row][col] = newStartNode;\r\n  newGrid[startNodeIndex.row][startNodeIndex.col].isStart = false;\r\n  document.getElementById(\r\n    `${startNodeIndex.row}:${startNodeIndex.col}`\r\n  ).className = \"Node\";\r\n\r\n  startNodeIndex.row = row;\r\n  startNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const setEndNode = (grid, row, col, endNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const newEndNode = {\r\n    ...node,\r\n    isEnd: true,\r\n  };\r\n\r\n  newGrid[row][col] = newEndNode;\r\n  newGrid[endNodeIndex.row][endNodeIndex.col].isEnd = false;\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`).className =\r\n    \"Node\";\r\n\r\n  endNodeIndex.row = row;\r\n  endNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const replaceGrid = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n        grid[i][j].nodeState = NodeStates.WALL;\r\n        grid[i][j].closed = false;\r\n      } else {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const clearVisitedNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        continue;\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./node\";\r\nimport NodeStates from \"./node-states\";\r\nimport \"./grid.css\";\r\nimport {\r\n  createGrid,\r\n  replaceGrid,\r\n  setNodeInGrid,\r\n  setStartNode,\r\n  setEndNode,\r\n  clearVisitedNodes,\r\n} from \"./grid-utilities\";\r\n\r\nexport default class Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isMouseDown: false,\r\n    };\r\n  }\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (this.isVisusualizing) return;\r\n\r\n    // set nextNodeState depending on current state of the node\r\n    let nextNodeState = NodeStates.WALL;\r\n    if (this.props.gridData[row][col].nodeState === NodeStates.WALL) {\r\n      nextNodeState = NodeStates.UNVISITED;\r\n    }\r\n\r\n    // set beginDragStart on StartNode click\r\n    if (this.props.gridData[row][col].isStart) {\r\n      this.beginDragStart = true;\r\n      return;\r\n    }\r\n\r\n    // set beginDragEnd on EndNode click\r\n    if (this.props.gridData[row][col].isEnd) {\r\n      this.beginDragEnd = true;\r\n      return;\r\n    }\r\n\r\n    // set State to t\r\n    this.tempGrid = setNodeInGrid(this.props.gridData, row, col, nextNodeState);\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseDownIntersect = () => {\r\n    if (this.isVisusualizing) return;\r\n    this.tempGrid = this.props.gridData;\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseLeave = () => {\r\n    if (this.isVisusualizing) return;\r\n    this.setState({ isMouseDown: false });\r\n  };\r\n\r\n  handleMouseUp() {\r\n    if (this.isVisusualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    if (this.beginDragStart) this.beginDragStart = false;\r\n    else if (this.beginDragEnd) this.beginDragEnd = false;\r\n\r\n    // set new grid and isMouseDown in state\r\n    this.setState({ isMouseDown: false });\r\n\r\n    this.props.updateGrid(this.tempGrid);\r\n    this.props.updateStartEndIndex(\r\n      this.props.startNodeIndex,\r\n      this.props.endNodeIndex\r\n    );\r\n  }\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (this.isVisusualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    const node = document.getElementById(`${row}:${col}`);\r\n    const grid = this.tempGrid;\r\n\r\n    if (this.beginDragStart) {\r\n      node.className = \"StartNode\";\r\n      this.tempGrid = setStartNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.props.startNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.beginDragEnd) {\r\n      node.className = \"EndNode\";\r\n      this.tempGrid = setEndNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.props.endNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.state.isMouseDown) {\r\n      node.className = \"WallNode\";\r\n      this.tempGrid = setNodeInGrid(grid, row, col, NodeStates.WALL);\r\n    }\r\n  };\r\n\r\n  preventDragHandler = (e) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  renderGrid() {\r\n    return (\r\n      <div className=\"GridContainer\">\r\n        <div\r\n          className=\"Grid\"\r\n          onDragStart={this.preventDragHandler}\r\n          onMouseLeave={this.handleMouseLeave}\r\n          onMouseUp={() => this.handleMouseUp()}\r\n          onMouseDown={() => this.handleMouseDownIntersect()}\r\n        >\r\n          {this.props.gridData.map((row, rowI) => {\r\n            return (\r\n              <div key={rowI}>\r\n                {row.map((node, nodeI) => (\r\n                  <Node\r\n                    col={node.col}\r\n                    row={node.row}\r\n                    isStart={node.isStart}\r\n                    isEnd={node.isEnd}\r\n                    isWall={node.isWall}\r\n                    shouldUpdate={node.shouldUpdate}\r\n                    nodeState={node.nodeState}\r\n                    closed={node.closed}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    onMouseDown={() => this.handleMouseDown(node.row, node.col)}\r\n                    onMouseEnter={() => this.handleMouseEnter(node.row, node.col)}\r\n                    onMouseLeave={() =>\r\n                      this.handleMouseLeave(node, row, node.col)\r\n                    }\r\n                    onDragStart={this.preventDragHandler} // prevents drag on this component\r\n                    key={`${node.row}:${node.col}`}\r\n                  />\r\n                ))}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return this.renderGrid();\r\n  }\r\n}\r\n","/***\r\n * An array implementation of a MinHeap\r\n * This implementation of MinHeap is meant to be used to store the Node object\r\n * The Node.distance will be used to compare and sort the nodes in the heap\r\n */\r\nexport default class MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n        this.map = new Map();\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    getNodeAt(key) {\r\n        const heapIndex = this.map.get(key);\r\n        const node = this.heap[heapIndex];\r\n        return node;\r\n    }\r\n\r\n    isHeap() {\r\n        // Start from root and go till the last internal \r\n        // node \r\n        for (let i = 0; i <= (this.heap.length - 2) / 2; i++) {\r\n            // If left child is greater, return false \r\n            if (this.heap[2 * i + 1] > this.heap[i])\r\n                return false;\r\n\r\n            // If right child is greater, return false \r\n            if (2 * i + 2 < this.heap.length && this.heap[2 * i + 2] > this.heap[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    insert(node) {\r\n        this.heap.push(node);\r\n        this.map.set(`${node.row}:${node.col}`, node);\r\n\r\n        let index = this.heap.length - 1;\r\n\r\n        while (index > 0) {\r\n            let element = this.heap[index];\r\n            let parent = this.heap[Math.floor((index - 1) / 2)];\r\n\r\n            if (parent.distance < element.distance) break;\r\n\r\n\r\n            this.swap(index, Math.floor((index - 1) / 2))\r\n            index = Math.floor((index - 1) / 2);\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        let smallest = this.heap[0];\r\n        this.map.delete(`${smallest.row}:${smallest.col}`);\r\n        this.heap[0] = this.heap.pop();\r\n        this.sinkDown(0);\r\n        return smallest;\r\n    }\r\n\r\n    sinkDown(index) {\r\n        let left = 2 * index + 1;\r\n        let right = 2 * index + 2;\r\n        let smallest = index;\r\n        const length = this.heap.length;\r\n\r\n        // if left child is greater than parent\r\n        if (\r\n            left < length &&\r\n            this.heap[left].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = left;\r\n        }\r\n        // if right child is greater than parent\r\n        if (\r\n            right < length &&\r\n            this.heap[right].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = right;\r\n        }\r\n        // swap\r\n        if (smallest !== index) {\r\n            this.swap(index, smallest)\r\n            this.sinkDown(smallest);\r\n        }\r\n    }\r\n\r\n    changeDistance(node, distance) {\r\n        // get node in map and set distance\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n\r\n        this.heap[heapIndex].distance = distance;\r\n\r\n        // heapify tree\r\n        while (heapIndex !== 0 && this.heap[heapIndex].distance < this.heap[Math.floor((heapIndex - 1) / 2)].distance) {\r\n            this.swap(heapIndex, Math.floor((heapIndex - 1) / 2))\r\n            heapIndex = Math.floor((heapIndex - 1) / 2);\r\n        }\r\n    }\r\n\r\n    setPreviousNode(node, previousNode) {\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n        this.heap[heapIndex].previousNode = previousNode;\r\n    }\r\n\r\n\r\n    swap(index1, index2){\r\n        const temp = this.heap[index1];\r\n        this.heap[index1] = this.heap[index2];\r\n        this.heap[index2] = temp;\r\n\r\n        this.map.set(`${this.heap[index1].row}:${this.heap[index1].col}`, index1)\r\n        this.map.set(`${this.heap[index2].row}:${this.heap[index2].col}`, index2)\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeAStar(grid, startNode, endNode) {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      grid[i][j].distance = 0;\r\n    }\r\n  }\r\n\r\n  var t0 = performance.now();\r\n\r\n  // init open and closed lists\r\n  startNode.distance = 0;\r\n  let open = new MinHeap();\r\n  let closed = [];\r\n\r\n  // add start node to open\r\n  open.insert(startNode);\r\n\r\n  // while open is not empty\r\n  while (open.map.size > 0) {\r\n    // remove the node with the smallest fCost\r\n    let closestNode = open.remove();\r\n    closed.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"AStar Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return closed;\r\n    }\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) {\r\n      continue;\r\n    }\r\n\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return closed;\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED\r\n\r\n    const neighbours = getAvailableNeighbours(closestNode, grid);\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (\r\n        closed.includes(neighbours[i]) ||\r\n        neighbours[i].nodeState === NodeStates.WALL\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // let gCost = closestNode.gCost + 10;\r\n      let gCost = closestNode.gCost + getNewGCost(neighbours[i], closestNode);\r\n\r\n      if (\r\n        open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n          undefined ||\r\n        gCost < neighbours[i].gCost\r\n      ) {\r\n        neighbours[i].previousNode = closestNode;\r\n        neighbours[i].hCost = getManhattanHCost(neighbours[i], endNode);\r\n        neighbours[i].gCost = gCost;\r\n        neighbours[i].distance = neighbours[i].gCost + neighbours[i].hCost;\r\n\r\n        if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n          undefined\r\n        ) {\r\n          open.insert(neighbours[i]);\r\n        } else if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) !==\r\n          undefined\r\n        ) {\r\n          open.changeDistance(neighbours[i], neighbours[i].distance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return closed;\r\n}\r\n\r\nexport function getAvailableNeighbours(node, grid) {\r\n  let neighbours = [];\r\n\r\n  if (node.row - 1 >= 0) neighbours.push(grid[node.row - 1][node.col]);\r\n\r\n  if (node.col + 1 < grid[0].length)\r\n    neighbours.push(grid[node.row][node.col + 1]);\r\n\r\n  if (node.row + 1 < grid.length) neighbours.push(grid[node.row + 1][node.col]);\r\n\r\n  if (node.col - 1 >= 0) neighbours.push(grid[node.row][node.col - 1]);\r\n\r\n  return neighbours;\r\n}\r\n\r\nconst getManhattanHCost = (currentNode, destNode) => {\r\n  const y = Math.abs(currentNode.row - destNode.row);\r\n  const x = Math.abs(currentNode.col - destNode.col);\r\n  return (x + y) * 9.9;\r\n};\r\n\r\nconst getNewGCost = (currentNode, closestNode) => {\r\n  if (closestNode.previousNode === null) {\r\n    return 10;\r\n  }\r\n\r\n  let firstDirection = [\r\n    closestNode.previousNode.row - closestNode.row,\r\n    closestNode.previousNode.col - closestNode.col,\r\n  ];\r\n  let secondDirection = [\r\n    closestNode.row - currentNode.row,\r\n    closestNode.col - currentNode.col,\r\n  ];\r\n\r\n  if (\r\n    firstDirection[0] === secondDirection[0] &&\r\n    firstDirection[1] === secondDirection[1]\r\n  ) {\r\n    return 9;\r\n  } else {\r\n    return 10;\r\n  }\r\n};\r\n\r\nexport const getShortestPath = (startNode, endNode) => {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== startNode) {\r\n    if (currentNode === null || currentNode === undefined) break;\r\n    // currentNode.nodeState = NodeStates.SHORTESTPATH;\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  shortestPath.push(startNode);\r\n  return shortestPath.reverse();\r\n};\r\n","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeDijkstra(grid, startNode, endNode) {\r\n  var t0 = performance.now();\r\n\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = new MinHeap();\r\n  unvisitedNodes = getAllNodesHeap(grid);\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    const closestNode = unvisitedNodes.remove();\r\n    const neighbours = getAvailableNeighboursHeap(closestNode, unvisitedNodes);\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) continue;\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const newDistance = closestNode.distance + 1;\r\n\r\n      unvisitedNodes.changeDistance(neighbours[i], newDistance);\r\n      unvisitedNodes.setPreviousNode(neighbours[i], closestNode);\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED;\r\n    closestNode.closed = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"Dijkstra Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getAllNodesHeap(grid) {\r\n  const nodes = new MinHeap();\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      nodes.insert(grid[row][col]);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getAvailableNeighboursHeap(node, heap) {\r\n  let neighbours = [];\r\n\r\n  const topNeighbour = heap.getNodeAt(`${node.row - 1}:${node.col}`);\r\n  if (topNeighbour !== undefined) neighbours.push(topNeighbour);\r\n\r\n  const rightNeighbour = heap.getNodeAt(`${node.row}:${node.col + 1}`);\r\n  if (rightNeighbour !== undefined) neighbours.push(rightNeighbour);\r\n\r\n  const bottomNeighbour = heap.getNodeAt(`${node.row + 1}:${node.col}`);\r\n  if (bottomNeighbour !== undefined) neighbours.push(bottomNeighbour);\r\n\r\n  const leftNeighbour = heap.getNodeAt(`${node.row}:${node.col - 1}`);\r\n  if (leftNeighbour !== undefined) neighbours.push(leftNeighbour);\r\n\r\n  //   return neighbours.filter(\r\n  //     (neighbour) => neighbour.nodeState === NodeStates.UNVISITED\r\n  //   );\r\n\r\n  return neighbours.filter((neighbour) => neighbour.closed !== true);\r\n}\r\n\r\nexport function getShortestPath(endNode) {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    currentNode.nodeState = NodeStates.SHORTESTPATH;\r\n    shortestPath.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return shortestPath;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./path-finding-visualizer.css\";\r\nimport Grid from \"./grid\";\r\nimport NodeStates from \"./node-states\";\r\nimport {\r\n  createGrid,\r\n  replaceGrid,\r\n  clearVisitedNodes,\r\n} from \"./grid-utilities\";\r\nimport { executeAStar, getShortestPath } from \"../algorithms/a-star\";\r\nimport { executeDijkstra } from \"../algorithms/dijkstra\";\r\nimport Dropdown from \"react-bootstrap/Dropdown\";\r\nimport DropdownButton from \"react-bootstrap/Dropdownbutton\";\r\n\r\nlet FIRST_START_INDEX = [10, 5];\r\nlet FIRST_END_INDEX = [10, 30];\r\n\r\nexport default class PathFindindVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      selectedAlgo: executeDijkstra,\r\n      selectedAlgoName: \"Dijkstra\",\r\n      width: 0,\r\n      height: 0,\r\n      grid: [],\r\n    };\r\n\r\n    this.startNodeIndex = {\r\n      row: FIRST_START_INDEX[0],\r\n      col: FIRST_START_INDEX[1],\r\n    };\r\n\r\n    this.endNodeIndex = {\r\n      row: FIRST_END_INDEX[0],\r\n      col: FIRST_END_INDEX[1],\r\n    };\r\n\r\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.updateArrayLength();\r\n    window.addEventListener(\"resize\", this.updateWindowDimensions);\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    );\r\n    this.setState({selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\"});\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateWindowDimensions);\r\n  }\r\n\r\n  updateWindowDimensions() {\r\n    this.updateArrayLength();\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    );\r\n    this.setState({\r\n      grid: newGrid,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  }\r\n\r\n  updateArrayLength() {\r\n    this.nodeSize = 24;\r\n    this.rowCount = Math.floor(\r\n      (window.innerHeight - window.innerHeight / 5) / this.nodeSize\r\n    );\r\n    this.colCount = Math.floor(\r\n      (window.innerWidth - window.innerWidth / 18) / this.nodeSize\r\n    );\r\n\r\n    let root = document.documentElement;\r\n    root.style.setProperty(\"--nodeSize\", this.nodeSize + \"px\");\r\n  }\r\n\r\n  reset() {\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    );\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(this.state.grid, this.startNodeIndex, this.endNodeIndex);\r\n    this.isVisusualizing = false;\r\n    clearTimeout(this.visitedAnimationTimeout);\r\n    clearTimeout(this.shortestPathTimeout);\r\n  }\r\n\r\n  executePathfinding() {\r\n    if (this.isVisusualizing) return;\r\n\r\n    const grid = this.state.grid;\r\n    const newGrid = replaceGrid(grid, this.startNodeIndex, this.endNodeIndex);\r\n\r\n    clearVisitedNodes(newGrid, this.startNodeIndex, this.endNodeIndex);\r\n\r\n    const visitedNodesInOrder = this.state.selectedAlgo(\r\n      newGrid,\r\n      newGrid[this.startNodeIndex.row][this.startNodeIndex.col],\r\n      newGrid[this.endNodeIndex.row][this.endNodeIndex.col]\r\n    );\r\n\r\n    const shortestPathNodes = getShortestPath(\r\n      newGrid[this.startNodeIndex.row][this.startNodeIndex.col],\r\n      newGrid[this.endNodeIndex.row][this.endNodeIndex.col]\r\n    );\r\n\r\n    this.visualize(visitedNodesInOrder, shortestPathNodes);\r\n  }\r\n\r\n  // Visualize visited nodes and shortest path (by calling visualizeShortestPath) on\r\n  visualize(visitedNodesInOrder, shortestPath) {\r\n    this.isVisusualizing = true;\r\n\r\n    if (visitedNodesInOrder.length === 1) {\r\n      this.isVisusualizing = false;\r\n      return;\r\n    }\r\n\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        this.shortestPathTimeout = setTimeout(() => {\r\n          if (shortestPath !== null) this.visualizeShortestPath(shortestPath);\r\n          return;\r\n        }, 5 * i);\r\n      }\r\n\r\n      const row = visitedNodesInOrder[i].row;\r\n      const col = visitedNodesInOrder[i].col;\r\n\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      this.visitedAnimationTimeout = setTimeout(() => {\r\n        visitedNodesInOrder[i].nodeState = NodeStates.VISITED;\r\n        node.className = \"VisitedNode\";\r\n      }, 5 * i);\r\n    }\r\n  }\r\n\r\n  // Visualize shortestPath from array recieved in params\r\n  visualizeShortestPath(shortestPath) {\r\n    const grid = this.state.grid;\r\n    this.isVisusualizing = true;\r\n\r\n    if (shortestPath.length === 1) {\r\n      this.isVisusualizing = false;\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const row = shortestPath[i].row;\r\n      const col = shortestPath[i].col;\r\n      grid[row][col] = shortestPath[i];\r\n      const node = document.getElementById(`${row}:${col}`);\r\n\r\n      setTimeout(() => {\r\n        if (node !== null) {\r\n          shortestPath[i].nodeState = NodeStates.SHORTESTPATH;\r\n          node.className = \"ShortestPathNode\";\r\n        }\r\n        if (i === shortestPath.length - 1) {\r\n          this.isVisusualizing = false;\r\n        }\r\n      }, 40 * i);\r\n    }\r\n  }\r\n\r\n  updateGrid = (newGrid) => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  updateStartEndIndex = (startNode, endNode) => {\r\n    this.startNodeIndex = startNode;\r\n    this.endNodeIndex = endNode;\r\n  };\r\n\r\n  selectAlgorithm = (selectedAlgo) => {\r\n    if (selectedAlgo === \"Dijkstra\")  this.setState({selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\"});\r\n\r\n\r\n    if (selectedAlgo === \"A*\")  this.setState({selectedAlgo: executeAStar, selectedAlgoName: \"A*\"});\r\n\r\n  };\r\n\r\n  render() {\r\n    \r\n    return (\r\n      <div style = {{height:\"100vh\"}} className=\"PathFindingVisualizer\">\r\n        <div className=\"Header\">\r\n          <div className=\"TitleContainer\">\r\n            <h1 className=\"TitleText\">Pathfinding Visualizer</h1>\r\n          </div>\r\n          <div className=\"DropDownContainer\">\r\n            <DropdownButton id=\"DropDown\" title=\"Pathfinding\">\r\n                <Dropdown.Item id=\"MenuItem\" onClick={()=> this.selectAlgorithm('Dijkstra')}>Dijkstra's Algorithm</Dropdown.Item>\r\n                <Dropdown.Item id=\"MenuItem\" onClick={()=> this.selectAlgorithm('A*')} as=\"button\">A* Algorithm</Dropdown.Item>\r\n            </DropdownButton>\r\n\r\n              {/* <DropdownButton id=\"DropDown\" title=\"Select Maze  \">\r\n                <Dropdown.Item id=\"MenuItem\" as=\"button\">Array</Dropdown.Item>\r\n                <Dropdown.Item id=\"MenuItem\" as=\"button\">Heap</Dropdown.Item>\r\n              </DropdownButton> */}\r\n\r\n            <button className=\"VisualizeButton\" onClick={() => this.executePathfinding()}>Visualize { this.state.selectedAlgoName }</button>\r\n            <button className=\"ResetButton\" onClick={() => this.reset()}>Reset</button>\r\n          </div>\r\n        </div>\r\n\r\n\r\n        <Grid\r\n          updateGrid={this.updateGrid}\r\n          updateStartEndIndex={this.updateStartEndIndex}\r\n          gridData={this.state.grid}\r\n          startNodeIndex={this.startNodeIndex}\r\n          endNodeIndex={this.endNodeIndex}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './path-finding-visualizer/path-finding-visualizer'\r\n\r\nfunction App() {\r\n  return (\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}