{"version":3,"sources":["path-finding-visualizer/node-states.js","path-finding-visualizer/node.jsx","path-finding-visualizer/grid-utilities.js","path-finding-visualizer/grid.jsx","path-finding-visualizer/help.jsx","algorithms/binary-tree.js","algorithms/random.js","data-structures/min-heap.js","algorithms/a-star.js","algorithms/dijkstra.js","path-finding-visualizer/path-finding-visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["NodeStates","VISITED","UNVISITED","WALL","SHORTESTPATH","Node","props","state","nodeState","isStart","isEnd","nextProps","hasNodeStateChanged","this","isStartChanged","isEndChanged","row","col","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","id","onDragStart","preventDragHandler","className","Component","createGrid","rowCount","colCount","startNodeIndex","endNodeIndex","grid","i","j","push","createNode","distance","Infinity","gCost","hCost","previousState","closed","previousNode","setNodeInGrid","node","newNode","previousNodeState","clearVisitedNodes","length","document","getElementById","clearWallNodes","getClassFromState","Grid","handleMouseDown","isVisualizing","nextNodeState","gridData","beginDragStart","beginDragEnd","tempGrid","setState","isMouseDown","handleMouseDownIntersect","isVisusualizing","handleMouseLeave","handleMouseEnter","newGrid","newStartNode","firstElementChild","setStartNode","newEndNode","setEndNode","e","preventDefault","updateGrid","updateStartEndIndex","handleMouseUp","map","rowI","key","nodeI","isWall","shouldUpdate","renderGrid","Help","isVisible","prevProps","executeBinaryTree","startNode","endNode","neighbours","NodeState","rand","Math","floor","random","filter","neighbour","getAllNodesInGrid","executeRandom","MinHeap","heap","Map","heapIndex","get","set","index","element","swap","smallest","delete","pop","sinkDown","left","right","index1","index2","temp","executeAStar","t0","performance","now","open","insert","size","closestNode","remove","t1","console","log","getAvailableNeighbours","includes","getNewGCost","undefined","getNodeAt","getManhattanHCost","changeDistance","currentNode","destNode","y","abs","firstDirection","secondDirection","executeDijkstra","unvisitedNodes","nodes","getAllNodesHeap","visitedNodesInOrder","getAvailableNeighboursHeap","newDistance","setPreviousNode","topNeighbour","rightNeighbour","bottomNeighbour","leftNeighbour","PathFindindVisualizer","visualize","shortestPath","shortestPathTimeout","setTimeout","visualizeShortestPath","visitedAnimationTimeout","selectAlgorithm","selectedAlgo","selectedAlgoName","selectedMazeAlgo","selectedMazeAlgoName","isHelpVisible","width","height","isMaze","updateWindowDimensions","bind","updateArrayLength","window","addEventListener","removeEventListener","reset","innerWidth","innerHeight","nodeSize","documentElement","style","setProperty","Array","from","forEach","clearTimeout","replaceGrid","shortestPathNodes","reverse","getShortestPath","toWaitBeforeEnded","maze","DropdownButton","title","Dropdown","Item","onClick","as","executePathfinding","visualizeMaze","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"8WAOeA,G,YAPI,CACfC,QAAS,UACTC,UAAW,YACXC,KAAM,OACNC,aAAc,iBCAGC,E,kDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACXC,UAAWR,EAAWE,UACtBO,SAAS,EACTC,OAAO,GALQ,E,kEAUGC,GACpB,IAAMC,EAAsBC,KAAKP,MAAME,YAAcG,EAAUH,UACzDM,EAAiBD,KAAKP,MAAMG,UAAYE,EAAUF,QAClDM,EAAeF,KAAKP,MAAMI,QAAUC,EAAUD,MAEpD,OAAOE,GAAuBE,GAAkBC,I,+BAYxC,IAAD,EACkEF,KAAKP,MAAtEU,EADD,EACCA,IAAKC,EADN,EACMA,IAAKC,EADX,EACWA,YAAaC,EADxB,EACwBA,aAAcC,EADtC,EACsCA,UAAWC,EADjD,EACiDA,aAExD,OAAIR,KAAKP,MAAMG,QAEX,yBACEa,GAAE,UAAKN,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBK,YAAaV,KAAKW,mBAClBC,UAAU,QAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,GACtBQ,UAAU,kBAGPZ,KAAKP,MAAMI,MAElB,yBACEY,GAAE,UAAKN,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBK,YAAaV,KAAKW,mBAClBC,UAAU,QAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,GACtBQ,UAAU,gBAGPZ,KAAKN,MAAMC,YAAcR,EAAWG,KAE3C,yBACEmB,GAAE,UAAKN,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBC,aAAc,kBAAMA,EAAaH,EAAKC,IACtCI,aAAc,kBAAMA,EAAaL,EAAKC,IACtCM,YAAaV,KAAKW,mBAClBC,UAAU,YAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,MAGnBJ,KAAKN,MAAMC,YAAcR,EAAWE,UAE3C,yBACEoB,GAAE,UAAKN,EAAL,YAAYC,GACdC,YAAa,kBAAMA,EAAYF,EAAKC,IACpCG,UAAW,kBAAMA,KACjBD,aAAc,kBAAMA,EAAaH,EAAKC,IACtCI,aAAc,kBAAMA,EAAaL,EAAKC,IACtCM,YAAaV,KAAKW,mBAClBC,UAAU,QAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,GAAOQ,UAAU,MAGpCZ,KAAKN,MAAMC,YAAcR,EAAWC,QAE3C,yBACEqB,GAAE,UAAKN,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBC,aAAc,kBAAMA,EAAaH,EAAKC,IACtCI,aAAc,kBAAMA,EAAaL,EAAKC,IACtCM,YAAaV,KAAKW,mBAClBC,UAAU,qBAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,MAGnBJ,KAAKN,MAAMC,YAAcR,EAAWI,aAE3C,yBACEkB,GAAE,UAAKN,EAAL,YAAYC,GACdG,UAAW,kBAAMA,KACjBF,YAAa,kBAAMA,KACnBC,aAAc,kBAAMA,EAAaH,EAAKC,IACtCI,aAAc,kBAAMA,EAAaL,EAAKC,IACtCM,YAAaV,KAAKW,mBAClBC,UAAU,0BAEV,yBAAKH,GAAE,UAAKN,EAAL,iBAAiBC,MAIrB,iD,gDA9FqBN,GAC9B,MAAO,CACLH,UAAWG,EAAUH,UACrBC,QAASE,EAAUF,QACnBC,MAAOC,EAAUD,W,GAxBWgB,a,QCFrBC,EAAa,SACxBC,EACAC,EACAC,EACAC,GAGA,IADA,IAAIC,EAAO,GACFC,EAAI,EAAGA,EAAIL,EAAUK,IAAK,CAGjC,IAFA,IAAIjB,EAAM,GAEDkB,EAAI,EAAGA,EAAIL,EAAUK,IAC5BlB,EAAImB,KAAKC,EAAWH,EAAGC,EAAGJ,EAAgBC,IAE5CC,EAAKG,KAAKnB,GAEZ,OAAOgB,GAGII,EAAa,SAACpB,EAAKC,EAAKa,EAAgBC,GACnD,IAAItB,GAAU,EACVC,GAAQ,EAKZ,OAHIM,IAAQc,EAAed,KAAOC,IAAQa,EAAeb,IAAKR,GAAU,EAC/DO,IAAQe,EAAaf,KAAOC,IAAQc,EAAad,MAAKP,GAAQ,GAEhE,CACLM,MACAC,MACAR,QAASA,EACTC,MAAOA,EACP2B,SAAUC,IACVC,MAAO,EACPC,MAAO,EACPC,cAAezC,EAAWE,UAC1BwC,QAAQ,EACRC,aAAc,KACdnC,UAAWR,EAAWE,YAIb0C,EAAgB,SAACZ,EAAMhB,EAAKC,EAAKT,GAC5C,IAAMqC,EAAOb,EAAKhB,GAAKC,GAEjB6B,EAAO,2BACRD,GADQ,IAEXE,kBAAmBvC,EACnBA,UAAWA,IAGb,OADAwB,EAAKhB,GAAKC,GAAO6B,EACVd,GA8EIgB,EAAoB,SAAChB,EAAMF,EAAgBC,GACtD,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAAK,CACvC,IAAMW,EAAOK,SAASC,eAAT,UAA2BlB,EAA3B,YAAgCC,IAEzCD,IAAMH,EAAed,KAAOkB,IAAMJ,EAAeb,IAIjDgB,IAAMF,EAAaf,KAAOkB,IAAMH,EAAad,IAI7Ce,EAAKC,GAAGC,GAAG1B,YAAcR,EAAWG,OAGtC0C,EAAKpB,UAAY,QANjBoB,EAAKpB,UAAY,UAJjBoB,EAAKpB,UAAY,cAgBZ2B,EAAiB,SAACpB,EAAMF,EAAgBC,GACnD,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAAK,CACvC,IAAMW,EAAOK,SAASC,eAAT,UAA2BlB,EAA3B,YAAgCC,IAEzCD,IAAMH,EAAed,KAAOkB,IAAMJ,EAAeb,IAIjDgB,IAAMF,EAAaf,KAAOkB,IAAMH,EAAad,KAI7Ce,EAAKC,GAAGC,GAAG1B,UACbqC,EAAKpB,UAAY,QAJjBoB,EAAKpB,UAAY,UAJjBoB,EAAKpB,UAAY,cAgBnB4B,EAAoB,SAAC9C,GACzB,OAAIA,IAAUP,EAAWE,UAAkB,OACvCK,IAAUP,EAAWC,QAAgB,oBACrCM,IAAUP,EAAWG,KAAa,WAClCI,IAAUP,EAAWI,aAAqB,8BAA9C,GCvKmBkD,E,kDACnB,WAAYhD,GAAQ,IAAD,8BACjB,cAAMA,IAURiD,gBAAkB,SAACvC,EAAKC,GACtB,IAAI,EAAKX,MAAMkD,cAAf,CAGA,IAAIC,EAAgBzD,EAAWG,KAC3B,EAAKG,MAAMoD,SAAS1C,GAAKC,GAAKT,YAAcR,EAAWG,OACzDsD,EAAgBzD,EAAWE,WAIzB,EAAKI,MAAMoD,SAAS1C,GAAKC,GAAKR,QAChC,EAAKkD,gBAAiB,EAKpB,EAAKrD,MAAMoD,SAAS1C,GAAKC,GAAKP,MAChC,EAAKkD,cAAe,GAKtB,EAAKC,SAAWjB,EAAc,EAAKtC,MAAMoD,SAAU1C,EAAKC,EAAKwC,GAC7D,EAAKK,SAAS,CAAEC,aAAa,OAlCZ,EAqCnBC,yBAA2B,WACrB,EAAKzD,MAAM0D,kBACf,EAAKJ,SAAW,EAAKvD,MAAMoD,SAC3B,EAAKI,SAAS,CAAEC,aAAa,MAxCZ,EA2CnBG,iBAAmB,SAAClD,EAAKC,GACvB,GAAI,EAAK0C,gBAAkB,EAAKC,aAAc,CAC5C,IAAMf,EAAO,EAAKvC,MAAMoD,SAAS1C,GAAKC,GACtC4B,EAAKrC,UAAYqC,EAAKJ,gBA9CP,EAmEnB0B,iBAAmB,SAACnD,EAAKC,GACvB,IAAI,EAAKX,MAAMkD,eACV,EAAKjD,MAAMwD,YAAhB,CAEA,IAAMlB,EAAOK,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IACzCe,EAAO,EAAK6B,SAElB,OAAI,EAAKF,gBACPd,EAAKpB,UAAY,iBACjB,EAAKoC,SDjCiB,SAAC7B,EAAMhB,EAAKC,EAAKa,GAC3C,IAAMsC,EAAUpC,EACVa,EAAOuB,EAAQpD,GAAKC,GAEpBwB,EAAgBI,EAAKrC,UAErB6D,EAAY,2BACbxB,GADa,IAEhBJ,cAAeA,EACfhC,SAAS,IAkBX,OAfA2D,EAAQpD,GAAKC,GAAOoD,EACpBD,EAAQtC,EAAed,KAAKc,EAAeb,KAAKR,SAAU,EAC1DyC,SAASC,eAAT,UACKrB,EAAed,IADpB,YAC2Bc,EAAeb,MACxCQ,UAAY4B,EAAkBrB,EAAKF,EAAed,KAAKc,EAAeb,KAAKwB,eAE7ES,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IAC/BqD,kBAAkB7C,UAAY,eAEjCyB,SAASC,eAAT,UAA2BrB,EAAed,IAA1C,YAAiDc,EAAeb,MAC7DqD,kBAAkB7C,UAAY,GAEjCK,EAAed,IAAMA,EACrBc,EAAeb,IAAMA,EAEdmD,ECMaG,CACd,EAAKjE,MAAMoD,SACX1C,EACAC,EACA,EAAKa,kBAGE,EAAK8B,cACdf,EAAKpB,UAAY,eACjB,EAAKoC,SDZe,SAAC7B,EAAMhB,EAAKC,EAAKc,GACzC,IAAMqC,EAAUpC,EACVa,EAAOuB,EAAQpD,GAAKC,GAEpBwB,EAAgBI,EAAKrC,UAErBgE,EAAU,2BACX3B,GADW,IAEdrC,UAAWR,EAAWE,UACtBuC,cAAeA,EACf/B,OAAO,IAiBT,OAdA0D,EAAQpD,GAAKC,GAAOuD,EACpBJ,EAAQrC,EAAaf,KAAKe,EAAad,KAAKP,OAAQ,EACpDwC,SAASC,eAAT,UAA2BpB,EAAaf,IAAxC,YAA+Ce,EAAad,MAAOQ,UACjE4B,EAAkBrB,EAAKD,EAAaf,KAAKe,EAAad,KAAKwB,eAE7DS,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IAC/BqD,kBAAkB7C,UAAY,aAEjCyB,SAASC,eAAT,UAA2BpB,EAAaf,IAAxC,YAA+Ce,EAAad,MACzDqD,kBAAkB7C,UAAY,GAEjCM,EAAaf,IAAMA,EACnBe,EAAad,IAAMA,EAEZmD,ECfaK,CACd,EAAKnE,MAAMoD,SACX1C,EACAC,EACA,EAAKX,MAAMyB,qBAGJ,EAAKxB,MAAMwD,cACpBlB,EAAKpB,UAAY,WACjB,EAAKoC,SAAWjB,EAAcZ,EAAMhB,EAAKC,EAAKjB,EAAWG,UA9F1C,EAkGnBqB,mBAAqB,SAACkD,GACpBA,EAAEC,kBAjGF,EAAKpE,MAAQ,CACXiD,eAAe,EACfO,aAAa,GAGf,EAAKjC,eAAiBxB,EAAMwB,eAC5B,EAAKC,aAAezB,EAAMyB,aART,E,4DAmDblB,KAAKP,MAAMkD,eACV3C,KAAKN,MAAMwD,cAEZlD,KAAK8C,eAAgB9C,KAAK8C,gBAAiB,EACtC9C,KAAK+C,eAAc/C,KAAK+C,cAAe,GAGhD/C,KAAKiD,SAAS,CAAEC,aAAa,IAE7BlD,KAAKP,MAAMsE,WAAW/D,KAAKgD,UAC3BhD,KAAKP,MAAMuE,oBACThE,KAAKiB,eACLjB,KAAKkB,iB,mCAuCK,IAAD,OAIX,OAHAlB,KAAKiB,eAAiBjB,KAAKP,MAAMwB,eACjCjB,KAAKkB,aAAelB,KAAKP,MAAMyB,aAG7B,yBAAKN,UAAU,iBACb,yBACEA,UAAU,OACVF,YAAaV,KAAKW,mBAElBJ,UAAW,kBAAM,EAAK0D,iBACtB5D,YAAa,kBAAM,EAAK8C,6BAEvBnD,KAAKP,MAAMoD,SAASqB,KAAI,SAAC/D,EAAKgE,GAC7B,OACE,yBAAKC,IAAKD,GACPhE,EAAI+D,KAAI,SAAClC,EAAMqC,GAAP,OACP,kBAAC,EAAD,CACEjE,IAAK4B,EAAK5B,IACVD,IAAK6B,EAAK7B,IACVP,QAASoC,EAAKpC,QACdC,MAAOmC,EAAKnC,MACZyE,OAAQtC,EAAKsC,OACbC,aAAcvC,EAAKuC,aACnB5E,UAAWqC,EAAKrC,UAChBkC,OAAQG,EAAKH,OACbtB,UAAW,kBAAM,EAAK0D,iBACtB5D,YAAa,kBAAM,EAAKqC,gBAAgBV,EAAK7B,IAAK6B,EAAK5B,MACvDE,aAAc,kBAAM,EAAKgD,iBAAiBtB,EAAK7B,IAAK6B,EAAK5B,MACzDI,aAAc,kBAAM,EAAK6C,iBAAiBrB,EAAK7B,IAAK6B,EAAK5B,MACzDM,YAAa,EAAKC,mBAClByD,IAAG,UAAKpC,EAAK7B,IAAV,YAAiB6B,EAAK5B,kB,+BAazC,OAAOJ,KAAKwE,iB,GAnJkB3D,aCNrB4D,G,MAAb,kDAEI,WAAYhF,GAAQ,IAAD,8BACf,cAAMA,IAEDC,MAAQ,CACTgF,WAAW,GAJA,EAFvB,+DAUuBC,GACXA,EAAUD,YAAc1E,KAAKP,MAAMiF,WACnC1E,KAAKiD,SAAS,CAAEyB,UAAW1E,KAAKP,MAAMiF,cAZlD,+BAiBQ,OAAI1E,KAAKN,MAAMgF,UAEP,yBAAK9D,UAAU,kBAKf,kCAxBhB,GAA0BC,cCGnB,SAAS+D,EAAkBzD,EAAM0D,EAAWC,GAC/CD,EAAUlF,UAAYR,EAAWE,UACjCyF,EAAQnF,UAAYR,EAAWE,UAC/BwF,EAAUhD,QAAS,EACnBiD,EAAQjD,QAAS,EAIjB,IAFA,IAEST,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,GAAK,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,GAAK,EAAG,CACxC,IAAI0D,EAAa,GAUjB,GARI3D,EAAI,EAAI,GACR2D,EAAWzD,KAAKH,EAAKC,EAAI,GAAGC,IAC5BA,EAAI,EAAI,GACR0D,EAAWzD,KAAKH,EAAKC,GAAGC,EAAI,IAE5BF,EAAKC,GAAGC,KAAOF,EAAK,GAAG,KACvBA,EAAKC,GAAGC,GAAGQ,QAAS,GAEE,IAAtBkD,EAAW3C,OAAf,CAGAyC,EAAUlF,UAAYR,EAAWE,UACjCyF,EAAQE,UAAY7F,EAAWE,UAE/B,IAAM4F,EAAOF,EAAWG,KAAKC,MAAMD,KAAKE,SAAWL,EAAW3C,SAE9DjB,EAAKC,GAAGC,GAAGQ,QAAS,EACpBV,EAAK8D,EAAK9E,KAAK8E,EAAK7E,KAAKyB,QAAS,GAG1C,OAGJ,SAA2BV,GACvB,IAAIoC,EAAU,GAEdA,EAAQjC,KAAKH,EAAK,GAAG,IAErB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAChCkC,EAAQjC,KAAKH,EAAKC,GAAGC,IAI7B,OAAOkC,EAAQ8B,QACX,SAACC,GAAD,OAAoC,IAArBA,EAAUzD,UAftB0D,CAAkBpE,GCpCtB,SAASqE,EAAcrE,EAAM0D,EAAWC,GAC3CD,EAAUlF,UAAYR,EAAWE,UACjCyF,EAAQnF,UAAYR,EAAWE,UAE/BwF,EAAUhD,QAAS,EACnBiD,EAAQjD,QAAS,EAEjB,IAAK,IAAIT,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAAK,CACxB6D,KAAKE,SACR,WAAWjE,EAAKC,GAAGC,GAAGQ,QAAS,GAGjD,OAGJ,SAA2BV,GACvB,IAAIoC,EAAU,GAEdA,EAAQjC,KAAKH,EAAK,GAAG,IAErB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAChCkC,EAAQjC,KAAKH,EAAKC,GAAGC,IAI7B,OAAOkC,EAAQ8B,QACX,SAACC,GAAD,OAAoC,IAArBA,EAAUzD,UAftB0D,CAAkBpE,G,ICXRsE,E,WACjB,aAAe,oBACXzF,KAAK0F,KAAO,GACZ1F,KAAKkE,IAAM,IAAIyB,I,qDAIf,OAAO3F,KAAK0F,KAAK,K,gCAGXtB,GACN,IAAMwB,EAAY5F,KAAKkE,IAAI2B,IAAIzB,GAE/B,OADapE,KAAK0F,KAAKE,K,+BAOvB,IAAK,IAAIxE,EAAI,EAAGA,IAAMpB,KAAK0F,KAAKtD,OAAS,GAAK,EAAGhB,IAAK,CAElD,GAAIpB,KAAK0F,KAAK,EAAItE,EAAI,GAAKpB,KAAK0F,KAAKtE,GACjC,OAAO,EAGX,GAAI,EAAIA,EAAI,EAAIpB,KAAK0F,KAAKtD,QAAUpC,KAAK0F,KAAK,EAAItE,EAAI,GAAKpB,KAAK0F,KAAKtE,GACjE,OAAO,EAEf,OAAO,I,6BAIJY,GACHhC,KAAK0F,KAAKpE,KAAKU,GACfhC,KAAKkE,IAAI4B,IAAT,UAAgB9D,EAAK7B,IAArB,YAA4B6B,EAAK5B,KAAO4B,GAIxC,IAFA,IAAI+D,EAAQ/F,KAAK0F,KAAKtD,OAAS,EAExB2D,EAAQ,GAAG,CACd,IAAIC,EAAUhG,KAAK0F,KAAKK,GAGxB,GAFa/F,KAAK0F,KAAKR,KAAKC,OAAOY,EAAQ,GAAK,IAErCvE,SAAWwE,EAAQxE,SAAU,MAGxCxB,KAAKiG,KAAKF,EAAOb,KAAKC,OAAOY,EAAQ,GAAK,IAC1CA,EAAQb,KAAKC,OAAOY,EAAQ,GAAK,M,+BAKrC,IAAIG,EAAWlG,KAAK0F,KAAK,GAIzB,OAHA1F,KAAKkE,IAAIiC,OAAT,UAAmBD,EAAS/F,IAA5B,YAAmC+F,EAAS9F,MAC5CJ,KAAK0F,KAAK,GAAK1F,KAAK0F,KAAKU,MACzBpG,KAAKqG,SAAS,GACPH,I,+BAGFH,GACL,IAAIO,EAAO,EAAIP,EAAQ,EACnBQ,EAAQ,EAAIR,EAAQ,EACpBG,EAAWH,EACT3D,EAASpC,KAAK0F,KAAKtD,OAIrBkE,EAAOlE,GACPpC,KAAK0F,KAAKY,GAAM9E,SAAWxB,KAAK0F,KAAKQ,GAAU1E,WAE/C0E,EAAWI,GAIXC,EAAQnE,GACRpC,KAAK0F,KAAKa,GAAO/E,SAAWxB,KAAK0F,KAAKQ,GAAU1E,WAEhD0E,EAAWK,GAGXL,IAAaH,IACb/F,KAAKiG,KAAKF,EAAOG,GACjBlG,KAAKqG,SAASH,M,qCAIPlE,EAAMR,GAEjB,IAAIoE,EAAY5F,KAAKkE,IAAI2B,IAAT,UAAgB7D,EAAK7B,IAArB,YAA4B6B,EAAK5B,MAKjD,IAHAJ,KAAK0F,KAAKE,GAAWpE,SAAWA,EAGX,IAAdoE,GAAmB5F,KAAK0F,KAAKE,GAAWpE,SAAWxB,KAAK0F,KAAKR,KAAKC,OAAOS,EAAY,GAAK,IAAIpE,UACjGxB,KAAKiG,KAAKL,EAAWV,KAAKC,OAAOS,EAAY,GAAK,IAClDA,EAAYV,KAAKC,OAAOS,EAAY,GAAK,K,sCAIjC5D,EAAMF,GAClB,IAAI8D,EAAY5F,KAAKkE,IAAI2B,IAAT,UAAgB7D,EAAK7B,IAArB,YAA4B6B,EAAK5B,MACjDJ,KAAK0F,KAAKE,GAAW9D,aAAeA,I,2BAInC0E,EAAQC,GACT,IAAMC,EAAO1G,KAAK0F,KAAKc,GACvBxG,KAAK0F,KAAKc,GAAUxG,KAAK0F,KAAKe,GAC9BzG,KAAK0F,KAAKe,GAAUC,EAEpB1G,KAAKkE,IAAI4B,IAAT,UAAgB9F,KAAK0F,KAAKc,GAAQrG,IAAlC,YAAyCH,KAAK0F,KAAKc,GAAQpG,KAAOoG,GAClExG,KAAKkE,IAAI4B,IAAT,UAAgB9F,KAAK0F,KAAKe,GAAQtG,IAAlC,YAAyCH,KAAK0F,KAAKe,GAAQrG,KAAOqG,O,KChHnE,SAASE,EAAaxF,EAAM0D,EAAWC,GAC5CD,EAAUlF,UAAYR,EAAWE,UACjCyF,EAAQnF,UAAYR,EAAWE,UAC/B,IAAK,IAAI+B,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAClCF,EAAKC,GAAGC,GAAGG,SAAW,EACtBL,EAAKC,GAAGC,GAAGQ,QAAS,EAIxB,IAAI+E,EAAKC,YAAYC,MAGrBjC,EAAUrD,SAAW,EACrB,IAAIuF,EAAO,IAAItB,EACX5D,EAAS,GAMb,IAHAkF,EAAKC,OAAOnC,GAGLkC,EAAK7C,IAAI+C,KAAO,GAAG,CAExB,IAAIC,EAAcH,EAAKI,SAGvB,GAFAtF,EAAOP,KAAK4F,GAERA,IAAgBpC,EAAS,CAC3B,IAAIsC,EAAKP,YAAYC,MAErB,OADAO,QAAQC,IAAI,eAAiBF,EAAKR,GAAM,kBACjC/E,EAGT,GAAIqF,EAAYvH,YAAcR,EAAWG,KAAzC,CAIA,GAAI4H,EAAY1F,WAAaC,IAE3B,OADA4F,QAAQC,IAAI,WACLzF,EAMT,IADA,IAAMkD,EAAawC,EAAuBL,EAAa/F,GAC9CC,EAAI,EAAGA,EAAI2D,EAAW3C,OAAQhB,IACrC,IACES,EAAO2F,SAASzC,EAAW3D,KAC3B2D,EAAW3D,GAAGzB,YAAcR,EAAWG,KAFzC,CAQA,IAAIoC,EAAQwF,EAAYxF,MAAQ+F,EAAY1C,EAAW3D,GAAI8F,SAIzDQ,IADAX,EAAKY,UAAL,UAAkB5C,EAAW3D,GAAGjB,IAAhC,YAAuC4E,EAAW3D,GAAGhB,OAErDsB,EAAQqD,EAAW3D,GAAGM,SAEtBqD,EAAW3D,GAAGU,aAAeoF,EAC7BnC,EAAW3D,GAAGO,MAAQiG,EAAkB7C,EAAW3D,GAAI0D,GACvDC,EAAW3D,GAAGM,MAAQA,EACtBqD,EAAW3D,GAAGI,SAAWuD,EAAW3D,GAAGM,MAAQqD,EAAW3D,GAAGO,WAI3D+F,IADAX,EAAKY,UAAL,UAAkB5C,EAAW3D,GAAGjB,IAAhC,YAAuC4E,EAAW3D,GAAGhB,MAGrD2G,EAAKC,OAAOjC,EAAW3D,SAGvBsG,IADAX,EAAKY,UAAL,UAAkB5C,EAAW3D,GAAGjB,IAAhC,YAAuC4E,EAAW3D,GAAGhB,OAGrD2G,EAAKc,eAAe9C,EAAW3D,GAAI2D,EAAW3D,GAAGI,aAKzD,OAAOK,EAGF,SAAS0F,EAAuBvF,EAAMb,GAC3C,IAAI4D,EAAa,GAWjB,OATI/C,EAAK7B,IAAM,GAAK,GAAG4E,EAAWzD,KAAKH,EAAKa,EAAK7B,IAAM,GAAG6B,EAAK5B,MAE3D4B,EAAK5B,IAAM,EAAIe,EAAK,GAAGiB,QACzB2C,EAAWzD,KAAKH,EAAKa,EAAK7B,KAAK6B,EAAK5B,IAAM,IAExC4B,EAAK7B,IAAM,EAAIgB,EAAKiB,QAAQ2C,EAAWzD,KAAKH,EAAKa,EAAK7B,IAAM,GAAG6B,EAAK5B,MAEpE4B,EAAK5B,IAAM,GAAK,GAAG2E,EAAWzD,KAAKH,EAAKa,EAAK7B,KAAK6B,EAAK5B,IAAM,IAE1D2E,EAGT,IAAM6C,EAAoB,SAACE,EAAaC,GACtC,IAAMC,EAAI9C,KAAK+C,IAAIH,EAAY3H,IAAM4H,EAAS5H,KAE9C,OAAiB,KADP+E,KAAK+C,IAAIH,EAAY1H,IAAM2H,EAAS3H,KAClC4H,IAGRP,EAAc,SAACK,EAAaZ,GAChC,GAAiC,OAA7BA,EAAYpF,aACd,OAAO,GAGT,IAAIoG,EAAiB,CACnBhB,EAAYpF,aAAa3B,IAAM+G,EAAY/G,IAC3C+G,EAAYpF,aAAa1B,IAAM8G,EAAY9G,KAEzC+H,EAAkB,CACpBjB,EAAY/G,IAAM2H,EAAY3H,IAC9B+G,EAAY9G,IAAM0H,EAAY1H,KAGhC,OACE8H,EAAe,KAAOC,EAAgB,IACtCD,EAAe,KAAOC,EAAgB,GAE/B,EAEA,IC3HJ,SAASC,EAAgBjH,EAAM0D,EAAWC,GAC/CD,EAAUlF,UAAYR,EAAWE,UACjCyF,EAAQnF,UAAYR,EAAWE,UAC/B,IAAIuH,EAAKC,YAAYC,MAErBjC,EAAUrD,SAAW,EACrB,IAAI6G,EAAiB,IAAI5C,EACzB4C,EAmCK,SAAyBlH,GAE9B,IADA,IAAMmH,EAAQ,IAAI7C,EACTtF,EAAM,EAAGA,EAAMgB,EAAKiB,OAAQjC,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMe,EAAK,GAAGiB,OAAQhC,IACtCkI,EAAMtB,OAAO7F,EAAKhB,GAAKC,IAG3B,OAAOkI,EA1CUC,CAAgBpH,GACjC,IAAMqH,EAAsB,GAI5B,IAFAA,EAAoBlH,KAAKuD,GAEQ,IAA1BwD,EAAejG,QAAc,CAClC,IAAM8E,EAAcmB,EAAelB,SAC7BpC,EAAa0D,EAA2BvB,EAAamB,GAE3D,GAAInB,EAAYvH,YAAcR,EAAWG,KAAzC,CACA,GAAI4H,EAAY1F,WAAaC,IAE3B,OADA4F,QAAQC,IAAI,WACLkB,EAGT,IAAK,IAAIpH,EAAI,EAAGA,EAAI2D,EAAW3C,OAAQhB,IAAK,CAC1C,IAAMsH,EAAcxB,EAAY1F,SAAW,EAE3C6G,EAAeR,eAAe9C,EAAW3D,GAAIsH,GAC7CL,EAAeM,gBAAgB5D,EAAW3D,GAAI8F,GAQhD,GAJAA,EAAYrF,QAAS,EAErB2G,EAAoBlH,KAAK4F,GAErBA,IAAgBpC,EAAS,CAC3B,IAAIsC,EAAKP,YAAYC,MAErB,OADAO,QAAQC,IAAI,kBAAoBF,EAAKR,GAAM,kBACpC4B,KAeN,SAASC,EAA2BzG,EAAM0D,GAC/C,IAAIX,EAAa,GAEX6D,EAAelD,EAAKiC,UAAL,UAAkB3F,EAAK7B,IAAM,EAA7B,YAAkC6B,EAAK5B,WACvCsH,IAAjBkB,GAA4B7D,EAAWzD,KAAKsH,GAEhD,IAAMC,EAAiBnD,EAAKiC,UAAL,UAAkB3F,EAAK7B,IAAvB,YAA8B6B,EAAK5B,IAAM,SACzCsH,IAAnBmB,GAA8B9D,EAAWzD,KAAKuH,GAElD,IAAMC,EAAkBpD,EAAKiC,UAAL,UAAkB3F,EAAK7B,IAAM,EAA7B,YAAkC6B,EAAK5B,WACvCsH,IAApBoB,GAA+B/D,EAAWzD,KAAKwH,GAEnD,IAAMC,EAAgBrD,EAAKiC,UAAL,UAAkB3F,EAAK7B,IAAvB,YAA8B6B,EAAK5B,IAAM,IAO/D,YANsBsH,IAAlBqB,GAA6BhE,EAAWzD,KAAKyH,GAM1ChE,EAAWM,QAAO,SAACC,GAAD,OAAoC,IAArBA,EAAUzD,U,mBCxD/BmH,E,kDACnB,WAAYvJ,GAAQ,IAAD,8BACjB,cAAMA,IAqIRwJ,UAAY,SAACT,EAAqBU,GAGhC,GAFA,EAAKjG,SAAS,CAAEN,eAAe,IAEI,IAA/B6F,EAAoBpG,OAKxB,IARiD,eAQxChB,GACHA,IAAMoH,EAAoBpG,OAAS,GACrC,EAAK+G,oBAAoB7H,KAAK8H,YAAW,WACvC,EAAKC,sBAAsBH,KAC1B,EAAI9H,IAGT,IAAMjB,EAAMqI,EAAoBpH,GAAGjB,IAC7BC,EAAMoI,EAAoBpH,GAAGhB,IAE7B4B,EAAOK,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IAC/C,EAAKkJ,wBAAwBhI,KAAK8H,YAAW,WAC3CZ,EAAoBpH,GAAGzB,UAAYR,EAAWC,QAC9C4C,EAAKpB,UAAY,gBAChB,EAAIQ,KAdAA,EAAI,EAAGA,EAAIoH,EAAoBpG,OAAQhB,IAAM,EAA7CA,QAJP,EAAK6B,SAAS,CAAEN,eAAe,KA1IhB,EA8OnBoB,WAAa,SAACR,GACZ,EAAKN,SAAS,CAAE9B,KAAMoC,KA/OL,EAkPnBS,oBAAsB,SAACa,EAAWC,GAChC,EAAK7B,SAAS,CAAEhC,eAAgB4D,IAChC,EAAK5B,SAAS,CAAE/B,aAAc4D,KApPb,EAuPnByE,gBAAkB,SAACC,GACI,aAAjBA,GAA6B,EAAKvG,SAAS,CAAEuG,aAAcpB,EAAiBqB,iBAAkB,aAC7E,OAAjBD,GAAuB,EAAKvG,SAAS,CAAEuG,aAAc7C,EAAc8C,iBAAkB,OACpE,eAAjBD,GAA+B,EAAKvG,SAAS,CAAEyG,iBAAkB9E,EAAmB+E,qBAAsB,gBACzF,WAAjBH,GAA2B,EAAKvG,SAAS,CAAEyG,iBAAkBlE,EAAemE,qBAAsB,YAzPtG,EAAKjK,MAAQ,CACXkK,eAAe,EACfJ,aAAcpB,EACdqB,iBAAkB,WAClBC,iBAAkB9E,EAClB+E,qBAAsB,cACtBE,MAAO,EACPC,OAAQ,EACRnH,eAAe,EACf1B,eAAgB,CAAEd,IAAK,GAAIC,IAAK,GAChCc,aAAc,CAAEf,IAAK,GAAIC,IAAK,IAC9Be,KAAM,IAGR,EAAKmI,wBAA0B,GAC/B,EAAKH,oBAAsB,GAC3B,EAAKY,QAAS,EACd,EAAKC,uBAAyB,EAAKA,uBAAuBC,KAA5B,gBAnBb,E,gEAuBjBjK,KAAKkK,oBACLC,OAAOC,iBAAiB,SAAUpK,KAAKgK,wBACvC,IAAMzG,EAAUzC,EACdd,KAAKe,SACLf,KAAKgB,SACLhB,KAAKN,MAAMuB,eACXjB,KAAKN,MAAMwB,cAEblB,KAAKiD,SAAS,CAAEuG,aAAcpB,EAAiBqB,iBAAkB,aACjEzJ,KAAKiD,SAAS,CAAE9B,KAAMoC,M,6CAItB4G,OAAOE,oBAAoB,SAAUrK,KAAKgK,0B,+CAI1ChK,KAAKkK,oBACLlK,KAAKsK,SAEDtK,KAAKN,MAAMuB,eAAed,IAAM,GAClCH,KAAKN,MAAMuB,eAAed,IAAMH,KAAKN,MAAMyB,KAAKiB,OAAS,GACzDpC,KAAKN,MAAMuB,eAAeb,IAAM,GAChCJ,KAAKN,MAAMuB,eAAeb,IAAMJ,KAAKN,MAAMyB,KAAK,GAAGiB,OAAS,GAC5DpC,KAAKN,MAAMwB,aAAaf,IAAM,GAC9BH,KAAKN,MAAMwB,aAAaf,IAAMH,KAAKN,MAAMyB,KAAKiB,OAAS,GACvDpC,KAAKN,MAAMwB,aAAad,IAAM,GAC9BJ,KAAKN,MAAMwB,aAAad,IAAMJ,KAAKN,MAAMyB,KAAK,GAAGiB,OAAS,IAC1DpC,KAAKiD,SAAS,CACZhC,eAAgB,CAAEd,IAAK+E,KAAKC,MAAM,GAAI/E,IAAK8E,KAAKC,MAAM,IACtDjE,aAAc,CAAEf,IAAK+E,KAAKC,MAAMnF,KAAKe,SAAW,GAAIX,IAAK8E,KAAKC,MAAMnF,KAAKgB,SAAW,MAIxF,IAAMuC,EAAUzC,EACdd,KAAKe,SACLf,KAAKgB,SACLhB,KAAKN,MAAMuB,eACXjB,KAAKN,MAAMwB,cAEblB,KAAKiD,SAAS,CACZ9B,KAAMoC,EACNsG,MAAOM,OAAOI,WACdT,OAAQK,OAAOK,gB,0CAKjBxK,KAAKyK,SAAW,GAChBzK,KAAKe,SAAWmE,KAAKC,OAClBgF,OAAOK,YAAcL,OAAOK,YAAc,GAAKxK,KAAKyK,UAEvDzK,KAAKgB,SAAWkE,KAAKC,OAClBgF,OAAOI,WAAaJ,OAAOI,WAAa,IAAMvK,KAAKyK,UAGlDzK,KAAKgB,SAAW,IAAM,IACxBhB,KAAKgB,UAAY,GAEfhB,KAAKe,SAAW,IAAM,IACxBf,KAAKe,UAAY,GAERsB,SAASqI,gBACfC,MAAMC,YAAY,aAAc5K,KAAKyK,SAAW,Q,8BAIrD,IAAMlH,EAAUzC,EACdd,KAAKe,SACLf,KAAKgB,SACLhB,KAAKN,MAAMuB,eACXjB,KAAKN,MAAMwB,cAGb2J,MAAMC,KAAK9K,KAAKmJ,qBAAqB4B,SAAQ,SAAA/E,GAC3CgF,aAAahF,MAEf6E,MAAMC,KAAK9K,KAAKsJ,yBAAyByB,SAAQ,SAAA/E,GAC/CgF,aAAahF,MAGfhG,KAAK+J,QAAS,EACd/J,KAAKiD,SAAS,CAAE9B,KAAMoC,IACtBpB,EAAkBnC,KAAKN,MAAMyB,KAAMnB,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cACzEqB,EAAevC,KAAKN,MAAMyB,KAAMnB,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cACtElB,KAAKiD,SAAS,CAAEN,eAAe,M,2CAI/B,IAAI3C,KAAKN,MAAMiD,cAAf,CAEA,IACMY,ERpBiB,SAACpC,EAAMF,EAAgBC,GAChD,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKiB,OAAQhB,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,GAAGiB,OAAQf,IAC9BF,EAAKC,GAAGC,GAAG1B,YAAcR,EAAWG,MACtC6B,EAAKC,GAAGC,GAAKE,EAAWH,EAAGC,EAAGJ,EAAgBC,GAC9CC,EAAKC,GAAGC,GAAG1B,UAAYR,EAAWG,KAClC6B,EAAKC,GAAGC,GAAGQ,QAAS,GAEpBV,EAAKC,GAAGC,GAAKE,EAAWH,EAAGC,EAAGJ,EAAgBC,GAIpD,OAAOC,EQQW8J,CADHjL,KAAKN,MAAMyB,KACUnB,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cAExEiB,EAAkBoB,EAASvD,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cAEjE,IAAMsH,EAAsBxI,KAAKN,MAAM8J,aACrCjG,EACAA,EAAQvD,KAAKN,MAAMuB,eAAed,KAAKH,KAAKN,MAAMuB,eAAeb,KACjEmD,EAAQvD,KAAKN,MAAMwB,aAAaf,KAAKH,KAAKN,MAAMwB,aAAad,MAGzD8K,EFdqB,SAACrG,EAAWC,GAGzC,IAFA,IAAMoE,EAAe,GACjBpB,EAAchD,EACXgD,IAAgBjD,GACD,OAAhBiD,QAAwCJ,IAAhBI,GAC5BoB,EAAa5H,KAAKwG,GAClBA,EAAcA,EAAYhG,aAG5B,OADAoH,EAAa5H,KAAKuD,GACXqE,EAAaiC,UEKQC,CACxB7H,EAAQvD,KAAKN,MAAMuB,eAAed,KAAKH,KAAKN,MAAMuB,eAAeb,KACjEmD,EAAQvD,KAAKN,MAAMwB,aAAaf,KAAKH,KAAKN,MAAMwB,aAAad,MAG/DJ,KAAKiJ,UAAUT,EAAqB0C,M,4CA+BhBhC,GAAe,IAAD,OAC5B/H,EAAOnB,KAAKN,MAAMyB,KAGxB,GAFAnB,KAAKiD,SAAS,CAAEN,eAAe,IAEH,IAAxBuG,EAAa9G,OAAjB,CAOA,IAFA,IAAIiJ,EAAoB,EATU,WAWzBjK,GACP,IAAMjB,EAAM+I,EAAa9H,GAAGjB,IACtBC,EAAM8I,EAAa9H,GAAGhB,IAC5Be,EAAKhB,GAAKC,GAAO8I,EAAa9H,GAC9B,IAAMY,EAAOK,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IAE/C,EAAK+I,oBAAoB7H,KAAK8H,YAAW,WAC1B,OAATpH,IACFkH,EAAa9H,GAAGzB,UAAYR,EAAWI,aACvCyC,EAAKpB,UAAY,sBAElB,GAAKQ,IACRiK,GAAqB,IAZdjK,EAAI,EAAGA,EAAI8H,EAAa9G,OAAQhB,IAAM,EAAtCA,GAeTgI,YAAW,WACT,EAAKnG,SAAS,CAAEN,eAAe,MAC9B0I,QAvBDrL,KAAKiD,SAAS,CAAEN,eAAe,M,sCA0BlB,IAAD,OACd,IAAI3C,KAAKN,MAAMiD,cAAf,CAEA,IAAMY,EAAUzC,EACdd,KAAKe,SACLf,KAAKgB,SACLhB,KAAKN,MAAMuB,eACXjB,KAAKN,MAAMwB,cAGblB,KAAKiD,SAAS,CAAE9B,KAAMoC,IACtBpB,EAAkBoB,EAASvD,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cACjEqB,EAAegB,EAASvD,KAAKN,MAAMuB,eAAgBjB,KAAKN,MAAMwB,cAE9D,IAAMoK,EAAOtL,KAAKN,MAAMgK,iBACtBnG,EACAA,EAAQvD,KAAKN,MAAMuB,eAAed,KAAKH,KAAKN,MAAMuB,eAAeb,KACjEmD,EAAQvD,KAAKN,MAAMwB,aAAaf,KAAKH,KAAKN,MAAMwB,aAAad,MAG/DJ,KAAKiD,SAAS,CAAEN,eAAe,IAG/B,IAFA,IAAI0I,EAAoB,EArBV,WAuBLjK,GACP,IAAMjB,EAAMmL,EAAKlK,GAAGjB,IACdC,EAAMkL,EAAKlK,GAAGhB,IACd4B,EAAOK,SAASC,eAAT,UAA2BnC,EAA3B,YAAkCC,IAC3C,EAAK2J,QACPuB,EAAKlK,GAAGzB,UAAYR,EAAWG,KAC/B0C,EAAKpB,UAAY,aAEjB,EAAK0I,wBAAwBhI,KAAK8H,YAAW,WAC3CkC,EAAKlK,GAAGzB,UAAYR,EAAWG,KAC/B0C,EAAKpB,UAAY,aAChB,EAAIQ,IACPiK,GAAqB,IAZhBjK,EAAI,EAAGA,EAAIkK,EAAKlJ,OAAQhB,IAAM,EAA9BA,GAgBTgI,YAAW,WACT,EAAKnG,SAAS,CAAEN,eAAe,MAC9B0I,GAEHrL,KAAK+J,QAAS,K,+BAmBN,IAAD,OACP,OACE,yBAAKY,MAAO,CAAEb,OAAQ,SAAWlJ,UAAU,yBACzC,yBAAKA,UAAU,UACb,yBAAKA,UAAU,aACb,wBAAIA,UAAU,aAAd,2BAGF,yBAAKA,UAAU,aACb,kBAAC2K,EAAA,EAAD,CAAgB9K,GAAG,WAAW+K,MAAM,0BAClC,kBAACC,EAAA,EAASC,KAAV,CAAejL,GAAG,WAAWkL,QAAS,kBAAM,EAAKpC,gBAAgB,cAAjE,wBACA,kBAACkC,EAAA,EAASC,KAAV,CAAejL,GAAG,WAAWkL,QAAS,kBAAM,EAAKpC,gBAAgB,OAAOqC,GAAG,UAA3E,iBAGF,4BAAQhL,UAAU,aAAa+K,QAAS,kBAAM,EAAKE,uBAAnD,aAAoF7L,KAAKN,MAAM+J,kBAE/F,kBAAC8B,EAAA,EAAD,CAAgB9K,GAAG,WAAW+K,MAAM,mBAClC,kBAACC,EAAA,EAASC,KAAV,CAAejL,GAAG,WAAWkL,QAAS,kBAAM,EAAKpC,gBAAgB,eAAeqC,GAAG,UAAnF,eACA,kBAACH,EAAA,EAASC,KAAV,CAAejL,GAAG,WAAWkL,QAAS,kBAAM,EAAKpC,gBAAgB,WAAWqC,GAAG,UAA/E,WAGF,4BAAQhL,UAAU,aAAa+K,QAAS,kBAAM,EAAKG,kBAAkB9L,KAAKN,MAAMiK,qBAAhF,UAIF,yBAAK/I,UAAU,aACb,4BAAQA,UAAU,mBAAmB+K,QAAS,kBAAM,EAAKrB,UAAzD,SACA,4BAAQ1J,UAAU,mBAAmB+K,QAAS,kBAAM,EAAK1I,SAAS,CAAE2G,eAAgB,EAAKlK,MAAMkK,kBAA/F,UAIJ,kBAAC,EAAD,CAAMlF,UAAW1E,KAAKN,MAAMkK,gBAE5B,kBAAC,EAAD,CACE7F,WAAY/D,KAAK+D,WACjBC,oBAAqBhE,KAAKgE,oBAC1BnB,SAAU7C,KAAKN,MAAMyB,KACrBF,eAAgBjB,KAAKN,MAAMuB,eAC3BC,aAAclB,KAAKN,MAAMwB,aACzByB,cAAgB3C,KAAKN,MAAMiD,qB,GAtSc9B,aCRpCkL,MANf,WACE,OACI,kBAAC,EAAD,OCMcC,QACW,cAA7B7B,OAAO8B,SAASC,UAEe,UAA7B/B,OAAO8B,SAASC,UAEhB/B,OAAO8B,SAASC,SAASC,MACvB,2D,MCVNC,IAASC,OAAO,kBAAC,EAAD,MAAShK,SAASC,eAAe,SD2H3C,kBAAmBgK,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.9fb2b2b7.chunk.js","sourcesContent":["const NodeStates = {\r\n    VISITED: \"visited\",\r\n    UNVISITED: \"unvisited\",\r\n    WALL: \"wall\",\r\n    SHORTESTPATH: 'shortestPath'\r\n  };\r\n\r\nexport default NodeStates;\r\n","import React, { Component } from \"react\";\r\nimport \"./grid.css\";\r\nimport NodeStates from \"./node-states\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodeState: NodeStates.UNVISITED,\r\n      isStart: false,\r\n      isEnd: false\r\n    };\r\n  }\r\n\r\n  /** Make sure not all nodes update every time the grid renders */\r\n  shouldComponentUpdate(nextProps) {\r\n    const hasNodeStateChanged = this.props.nodeState !== nextProps.nodeState;\r\n    const isStartChanged = this.props.isStart !== nextProps.isStart;\r\n    const isEndChanged = this.props.isEnd !== nextProps.isEnd;\r\n\r\n    return hasNodeStateChanged || isStartChanged || isEndChanged;\r\n  }\r\n\r\n  /** Change State based on property nodeState */\r\n  static getDerivedStateFromProps(nextProps) {\r\n    return {\r\n      nodeState: nextProps.nodeState,\r\n      isStart: nextProps.isStart,\r\n      isEnd: nextProps.isEnd\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const { row, col, onMouseDown, onMouseEnter, onMouseUp, onMouseLeave } = this.props;\r\n\r\n    if (this.props.isStart) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-start\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.props.isEnd) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`}\r\n            className=\"inside-end\"></div>\r\n        </div >\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.WALL) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"WallNode\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.UNVISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"Node\"\r\n        >\r\n          <div id={`${row}inside${col}`} className=\"\"></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.VISITED) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"VisitedNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else if (this.state.nodeState === NodeStates.SHORTESTPATH) {\r\n      return (\r\n        <div\r\n          id={`${row}:${col}`}\r\n          onMouseUp={() => onMouseUp()}\r\n          onMouseDown={() => onMouseDown()}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={() => onMouseLeave(row, col)}\r\n          onDragStart={this.preventDragHandler}\r\n          className=\"ShortestPathNodeNoAnim\"\r\n        >\r\n          <div id={`${row}inside${col}`}></div>\r\n        </div>\r\n      );\r\n    } else {\r\n      return <div>no such state</div>;\r\n    }\r\n  }\r\n}\r\n","import NodeStates from \"./node-states\";\r\n\r\nexport const createGrid = (\r\n  rowCount,\r\n  colCount,\r\n  startNodeIndex,\r\n  endNodeIndex\r\n) => {\r\n  let grid = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let row = [];\r\n\r\n    for (let j = 0; j < colCount; j++) {\r\n      row.push(createNode(i, j, startNodeIndex, endNodeIndex));\r\n    }\r\n    grid.push(row);\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const createNode = (row, col, startNodeIndex, endNodeIndex) => {\r\n  let isStart = false;\r\n  let isEnd = false;\r\n\r\n  if (row === startNodeIndex.row && col === startNodeIndex.col) isStart = true;\r\n  else if (row === endNodeIndex.row && col === endNodeIndex.col) isEnd = true;\r\n\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: isStart,\r\n    isEnd: isEnd,\r\n    distance: Infinity,\r\n    gCost: 0,\r\n    hCost: 0,\r\n    previousState: NodeStates.UNVISITED,\r\n    closed: false,\r\n    previousNode: null,\r\n    nodeState: NodeStates.UNVISITED,\r\n  };\r\n};\r\n\r\nexport const setNodeInGrid = (grid, row, col, nodeState) => {\r\n  const node = grid[row][col];\r\n\r\n  const newNode = {\r\n    ...node,\r\n    previousNodeState: nodeState,\r\n    nodeState: nodeState,\r\n  };\r\n  grid[row][col] = newNode;\r\n  return grid;\r\n};\r\n\r\nexport const setStartNode = (grid, row, col, startNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newStartNode = {\r\n    ...node,\r\n    previousState: previousState,\r\n    isStart: true,\r\n  };\r\n\r\n  newGrid[row][col] = newStartNode;\r\n  newGrid[startNodeIndex.row][startNodeIndex.col].isStart = false;\r\n  document.getElementById(\r\n    `${startNodeIndex.row}:${startNodeIndex.col}`\r\n  ).className = getClassFromState(grid[startNodeIndex.row][startNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-start\"\r\n\r\n  document.getElementById(`${startNodeIndex.row}:${startNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  startNodeIndex.row = row;\r\n  startNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const setEndNode = (grid, row, col, endNodeIndex) => {\r\n  const newGrid = grid;\r\n  const node = newGrid[row][col];\r\n\r\n  const previousState = node.nodeState;\r\n\r\n  const newEndNode = {\r\n    ...node,\r\n    nodeState: NodeStates.UNVISITED,\r\n    previousState: previousState,\r\n    isEnd: true,\r\n  };\r\n\r\n  newGrid[row][col] = newEndNode;\r\n  newGrid[endNodeIndex.row][endNodeIndex.col].isEnd = false;\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`).className =\r\n    getClassFromState(grid[endNodeIndex.row][endNodeIndex.col].previousState);\r\n\r\n  document.getElementById(`${row}:${col}`)\r\n    .firstElementChild.className = \"inside-end\"\r\n\r\n  document.getElementById(`${endNodeIndex.row}:${endNodeIndex.col}`)\r\n    .firstElementChild.className = \"\"\r\n\r\n  endNodeIndex.row = row;\r\n  endNodeIndex.col = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const replaceGrid = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n        grid[i][j].nodeState = NodeStates.WALL;\r\n        grid[i][j].closed = false;\r\n      } else {\r\n        grid[i][j] = createNode(i, j, startNodeIndex, endNodeIndex);\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport const clearVisitedNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        continue;\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const clearWallNodes = (grid, startNodeIndex, endNodeIndex) => {\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      const node = document.getElementById(`${i}:${j}`);\r\n\r\n      if (i === startNodeIndex.row && j === startNodeIndex.col) {\r\n        node.className = \"StartNode\";\r\n        continue;\r\n      }\r\n      if (i === endNodeIndex.row && j === endNodeIndex.col) {\r\n        node.className = \"EndNode\";\r\n        continue;\r\n      }\r\n      if (grid[i][j].nodeState === NodeStates.WALL) {\r\n        node.className = \"Node\";\r\n      } else {\r\n        node.className = \"Node\";\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst getClassFromState = (state) => {\r\n  if (state === NodeStates.UNVISITED) return \"Node\"\r\n  if (state === NodeStates.VISITED) return \"VisitedNodeNoAnim\"\r\n  if (state === NodeStates.WALL) return \"WallNode\"\r\n  if (state === NodeStates.SHORTESTPATH) return \"ShortestPathNodeNoAnim\"\r\n}","import React, { Component } from \"react\";\r\nimport Node from \"./node\";\r\nimport NodeStates from \"./node-states\";\r\nimport \"./grid.css\";\r\nimport {\r\n  setNodeInGrid,\r\n  setStartNode,\r\n  setEndNode,\r\n} from \"./grid-utilities\";\r\n\r\nexport default class Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isVisualizing: false,\r\n      isMouseDown: false,\r\n    };\r\n\r\n    this.startNodeIndex = props.startNodeIndex;\r\n    this.endNodeIndex = props.endNodeIndex;\r\n  }\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n\r\n    // set nextNodeState depending on current state of the node\r\n    let nextNodeState = NodeStates.WALL;\r\n    if (this.props.gridData[row][col].nodeState === NodeStates.WALL) {\r\n      nextNodeState = NodeStates.UNVISITED;\r\n    }\r\n\r\n    // set beginDragStart on StartNode click\r\n    if (this.props.gridData[row][col].isStart) {\r\n      this.beginDragStart = true;\r\n      return;\r\n    }\r\n\r\n    // set beginDragEnd on EndNode click\r\n    if (this.props.gridData[row][col].isEnd) {\r\n      this.beginDragEnd = true;\r\n      return;\r\n    }\r\n\r\n    // set State to t\r\n    this.tempGrid = setNodeInGrid(this.props.gridData, row, col, nextNodeState);\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseDownIntersect = () => {\r\n    if (this.state.isVisusualizing) return;\r\n    this.tempGrid = this.props.gridData;\r\n    this.setState({ isMouseDown: true });\r\n  };\r\n\r\n  handleMouseLeave = (row, col) => {\r\n    if (this.beginDragStart || this.beginDragEnd) {\r\n      const node = this.props.gridData[row][col]\r\n      node.nodeState = node.previousState\r\n    }\r\n  };\r\n\r\n  handleMouseUp() {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    if (this.beginDragStart) this.beginDragStart = false;\r\n    else if (this.beginDragEnd) this.beginDragEnd = false;\r\n\r\n    // set new grid and isMouseDown in state\r\n    this.setState({ isMouseDown: false });\r\n\r\n    this.props.updateGrid(this.tempGrid);\r\n    this.props.updateStartEndIndex(\r\n      this.startNodeIndex,\r\n      this.endNodeIndex\r\n    )\r\n  }\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (this.props.isVisualizing) return;\r\n    if (!this.state.isMouseDown) return;\r\n\r\n    const node = document.getElementById(`${row}:${col}`);\r\n    const grid = this.tempGrid;\r\n\r\n    if (this.beginDragStart) {\r\n      node.className = \"StartNode\";\r\n      this.tempGrid = setStartNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.startNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.beginDragEnd) {\r\n      node.className = \"EndNode\";\r\n      this.tempGrid = setEndNode(\r\n        this.props.gridData,\r\n        row,\r\n        col,\r\n        this.props.endNodeIndex\r\n      );\r\n      return;\r\n    } else if (this.state.isMouseDown) {\r\n      node.className = \"WallNode\";\r\n      this.tempGrid = setNodeInGrid(grid, row, col, NodeStates.WALL);\r\n    }\r\n  };\r\n\r\n  preventDragHandler = (e) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  renderGrid() {\r\n    this.startNodeIndex = this.props.startNodeIndex;\r\n    this.endNodeIndex = this.props.endNodeIndex;\r\n\r\n    return (\r\n      <div className=\"GridContainer\">\r\n        <div\r\n          className=\"Grid\"\r\n          onDragStart={this.preventDragHandler}\r\n          // onMouseLeave={this.handleMouseLeave}\r\n          onMouseUp={() => this.handleMouseUp()}\r\n          onMouseDown={() => this.handleMouseDownIntersect()}\r\n        >\r\n          {this.props.gridData.map((row, rowI) => {\r\n            return (\r\n              <div key={rowI}>\r\n                {row.map((node, nodeI) => (\r\n                  <Node\r\n                    col={node.col}\r\n                    row={node.row}\r\n                    isStart={node.isStart}\r\n                    isEnd={node.isEnd}\r\n                    isWall={node.isWall}\r\n                    shouldUpdate={node.shouldUpdate}\r\n                    nodeState={node.nodeState}\r\n                    closed={node.closed}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    onMouseDown={() => this.handleMouseDown(node.row, node.col)}\r\n                    onMouseEnter={() => this.handleMouseEnter(node.row, node.col)}\r\n                    onMouseLeave={() => this.handleMouseLeave(node.row, node.col)}\r\n                    onDragStart={this.preventDragHandler} // prevents drag on this component\r\n                    key={`${node.row}:${node.col}`}\r\n                  />\r\n                ))}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return this.renderGrid();\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./help.css\"\r\n\r\n\r\nexport class Help extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            isVisible: false,\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.isVisible !== this.props.isVisible) {\r\n            this.setState({ isVisible: this.props.isVisible })\r\n        }\r\n    }\r\n\r\n    render() {\r\n        if (this.state.isVisible) {\r\n            return (\r\n                <div className=\"HelpContainer\">\r\n                </div>\r\n            );\r\n        } else {\r\n            return (\r\n                <div></div>\r\n            )\r\n        }\r\n\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport {\r\n    setStartNode,\r\n    setEndNode\r\n} from '../path-finding-visualizer/grid-utilities'\r\n\r\n\r\nexport function executeBinaryTree(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    let toReturn = [];\r\n\r\n    for (let i = 1; i < grid.length; i += 2) {\r\n        for (let j = 1; j < grid[0].length; j += 2) {\r\n            let neighbours = [];\r\n\r\n            if (i - 1 > 0)\r\n                neighbours.push(grid[i - 1][j])\r\n            if (j - 1 > 0)\r\n                neighbours.push(grid[i][j - 1])\r\n\r\n            if (grid[i][j] === grid[1][1])\r\n                grid[i][j].closed = true;\r\n\r\n            if (neighbours.length === 0)\r\n                continue;\r\n\r\n            startNode.nodeState = NodeStates.UNVISITED;\r\n            endNode.NodeState = NodeStates.UNVISITED;\r\n\r\n            const rand = neighbours[Math.floor(Math.random() * neighbours.length)];\r\n\r\n            grid[i][j].closed = true;\r\n            grid[rand.row][rand.col].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\n\r\n\r\nexport function executeRandom(grid, startNode, endNode) {\r\n    startNode.nodeState = NodeStates.UNVISITED;\r\n    endNode.nodeState = NodeStates.UNVISITED\r\n\r\n    startNode.closed = true;\r\n    endNode.closed = true;\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const rand = Math.random();\r\n            if(rand > 0.3333333) grid[i][j].closed = true;\r\n        }\r\n    }\r\n    return getAllNodesInGrid(grid);\r\n}\r\n\r\nfunction getAllNodesInGrid(grid) {\r\n    let newGrid = [];\r\n\r\n    newGrid.push(grid[0][0]);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            newGrid.push(grid[i][j]);\r\n        }\r\n    }\r\n\r\n    return newGrid.filter(\r\n        (neighbour) => neighbour.closed === false\r\n    );\r\n}","/***\r\n * An array implementation of a MinHeap\r\n * This implementation of MinHeap is meant to be used to store the Node object\r\n * The Node.distance will be used to compare and sort the nodes in the heap\r\n */\r\nexport default class MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n        this.map = new Map();\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    getNodeAt(key) {\r\n        const heapIndex = this.map.get(key);\r\n        const node = this.heap[heapIndex];\r\n        return node;\r\n    }\r\n\r\n    isHeap() {\r\n        // Start from root and go till the last internal \r\n        // node \r\n        for (let i = 0; i <= (this.heap.length - 2) / 2; i++) {\r\n            // If left child is greater, return false \r\n            if (this.heap[2 * i + 1] > this.heap[i])\r\n                return false;\r\n\r\n            // If right child is greater, return false \r\n            if (2 * i + 2 < this.heap.length && this.heap[2 * i + 2] > this.heap[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    insert(node) {\r\n        this.heap.push(node);\r\n        this.map.set(`${node.row}:${node.col}`, node);\r\n\r\n        let index = this.heap.length - 1;\r\n\r\n        while (index > 0) {\r\n            let element = this.heap[index];\r\n            let parent = this.heap[Math.floor((index - 1) / 2)];\r\n\r\n            if (parent.distance < element.distance) break;\r\n\r\n\r\n            this.swap(index, Math.floor((index - 1) / 2))\r\n            index = Math.floor((index - 1) / 2);\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        let smallest = this.heap[0];\r\n        this.map.delete(`${smallest.row}:${smallest.col}`);\r\n        this.heap[0] = this.heap.pop();\r\n        this.sinkDown(0);\r\n        return smallest;\r\n    }\r\n\r\n    sinkDown(index) {\r\n        let left = 2 * index + 1;\r\n        let right = 2 * index + 2;\r\n        let smallest = index;\r\n        const length = this.heap.length;\r\n\r\n        // if left child is greater than parent\r\n        if (\r\n            left < length &&\r\n            this.heap[left].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = left;\r\n        }\r\n        // if right child is greater than parent\r\n        if (\r\n            right < length &&\r\n            this.heap[right].distance < this.heap[smallest].distance\r\n        ) {\r\n            smallest = right;\r\n        }\r\n        // swap\r\n        if (smallest !== index) {\r\n            this.swap(index, smallest)\r\n            this.sinkDown(smallest);\r\n        }\r\n    }\r\n\r\n    changeDistance(node, distance) {\r\n        // get node in map and set distance\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n\r\n        this.heap[heapIndex].distance = distance;\r\n\r\n        // heapify tree\r\n        while (heapIndex !== 0 && this.heap[heapIndex].distance < this.heap[Math.floor((heapIndex - 1) / 2)].distance) {\r\n            this.swap(heapIndex, Math.floor((heapIndex - 1) / 2))\r\n            heapIndex = Math.floor((heapIndex - 1) / 2);\r\n        }\r\n    }\r\n\r\n    setPreviousNode(node, previousNode) {\r\n        let heapIndex = this.map.get(`${node.row}:${node.col}`);\r\n        this.heap[heapIndex].previousNode = previousNode;\r\n    }\r\n\r\n\r\n    swap(index1, index2){\r\n        const temp = this.heap[index1];\r\n        this.heap[index1] = this.heap[index2];\r\n        this.heap[index2] = temp;\r\n\r\n        this.map.set(`${this.heap[index1].row}:${this.heap[index1].col}`, index1)\r\n        this.map.set(`${this.heap[index2].row}:${this.heap[index2].col}`, index2)\r\n    }\r\n}","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeAStar(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  for (let i = 0; i < grid.length; i++) {\r\n    for (let j = 0; j < grid[0].length; j++) {\r\n      grid[i][j].distance = 0;\r\n      grid[i][j].closed = false;\r\n    }\r\n  }\r\n\r\n  var t0 = performance.now();\r\n\r\n  // init open and closed lists\r\n  startNode.distance = 0;\r\n  let open = new MinHeap();\r\n  let closed = [];\r\n\r\n  // add start node to open\r\n  open.insert(startNode);\r\n\r\n  // while open is not empty\r\n  while (open.map.size > 0) {\r\n    // remove the node with the smallest fCost\r\n    let closestNode = open.remove();\r\n    closed.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"AStar Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return closed;\r\n    }\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) {\r\n      continue;\r\n    }\r\n\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return closed;\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED\r\n\r\n    const neighbours = getAvailableNeighbours(closestNode, grid);\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (\r\n        closed.includes(neighbours[i]) ||\r\n        neighbours[i].nodeState === NodeStates.WALL\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // let gCost = closestNode.gCost + 10;\r\n      let gCost = closestNode.gCost + getNewGCost(neighbours[i], closestNode);\r\n\r\n      if (\r\n        open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n        undefined ||\r\n        gCost < neighbours[i].gCost\r\n      ) {\r\n        neighbours[i].previousNode = closestNode;\r\n        neighbours[i].hCost = getManhattanHCost(neighbours[i], endNode);\r\n        neighbours[i].gCost = gCost;\r\n        neighbours[i].distance = neighbours[i].gCost + neighbours[i].hCost;\r\n\r\n        if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) ===\r\n          undefined\r\n        ) {\r\n          open.insert(neighbours[i]);\r\n        } else if (\r\n          open.getNodeAt(`${neighbours[i].row}:${neighbours[i].col}`) !==\r\n          undefined\r\n        ) {\r\n          open.changeDistance(neighbours[i], neighbours[i].distance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return closed;\r\n}\r\n\r\nexport function getAvailableNeighbours(node, grid) {\r\n  let neighbours = [];\r\n\r\n  if (node.row - 1 >= 0) neighbours.push(grid[node.row - 1][node.col]);\r\n\r\n  if (node.col + 1 < grid[0].length)\r\n    neighbours.push(grid[node.row][node.col + 1]);\r\n\r\n  if (node.row + 1 < grid.length) neighbours.push(grid[node.row + 1][node.col]);\r\n\r\n  if (node.col - 1 >= 0) neighbours.push(grid[node.row][node.col - 1]);\r\n\r\n  return neighbours;\r\n}\r\n\r\nconst getManhattanHCost = (currentNode, destNode) => {\r\n  const y = Math.abs(currentNode.row - destNode.row);\r\n  const x = Math.abs(currentNode.col - destNode.col);\r\n  return (x + y) * 9.9;\r\n};\r\n\r\nconst getNewGCost = (currentNode, closestNode) => {\r\n  if (closestNode.previousNode === null) {\r\n    return 10;\r\n  }\r\n\r\n  let firstDirection = [\r\n    closestNode.previousNode.row - closestNode.row,\r\n    closestNode.previousNode.col - closestNode.col,\r\n  ];\r\n  let secondDirection = [\r\n    closestNode.row - currentNode.row,\r\n    closestNode.col - currentNode.col,\r\n  ];\r\n\r\n  if (\r\n    firstDirection[0] === secondDirection[0] &&\r\n    firstDirection[1] === secondDirection[1]\r\n  ) {\r\n    return 9;\r\n  } else {\r\n    return 10;\r\n  }\r\n};\r\n\r\nexport const getShortestPath = (startNode, endNode) => {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== startNode) {\r\n    if (currentNode === null || currentNode === undefined) break;\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  shortestPath.push(startNode);\r\n  return shortestPath.reverse();\r\n};","import NodeStates from \"../path-finding-visualizer/node-states\";\r\nimport MinHeap from \"../data-structures/min-heap\";\r\n\r\nexport function executeDijkstra(grid, startNode, endNode) {\r\n  startNode.nodeState = NodeStates.UNVISITED;\r\n  endNode.nodeState = NodeStates.UNVISITED\r\n  var t0 = performance.now();\r\n\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = new MinHeap();\r\n  unvisitedNodes = getAllNodesHeap(grid);\r\n  const visitedNodesInOrder = [];\r\n\r\n  visitedNodesInOrder.push(startNode)\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    const closestNode = unvisitedNodes.remove();\r\n    const neighbours = getAvailableNeighboursHeap(closestNode, unvisitedNodes);\r\n\r\n    if (closestNode.nodeState === NodeStates.WALL) continue;\r\n    if (closestNode.distance === Infinity) {\r\n      console.log(\"NO PATH\");\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const newDistance = closestNode.distance + 1;\r\n\r\n      unvisitedNodes.changeDistance(neighbours[i], newDistance);\r\n      unvisitedNodes.setPreviousNode(neighbours[i], closestNode);\r\n    }\r\n\r\n    // closestNode.nodeState = NodeStates.VISITED;\r\n    closestNode.closed = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) {\r\n      var t1 = performance.now();\r\n      console.log(\"Dijkstra Took \" + (t1 - t0) + \" milliseconds.\");\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getAllNodesHeap(grid) {\r\n  const nodes = new MinHeap();\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      nodes.insert(grid[row][col]);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getAvailableNeighboursHeap(node, heap) {\r\n  let neighbours = [];\r\n\r\n  const topNeighbour = heap.getNodeAt(`${node.row - 1}:${node.col}`);\r\n  if (topNeighbour !== undefined) neighbours.push(topNeighbour);\r\n\r\n  const rightNeighbour = heap.getNodeAt(`${node.row}:${node.col + 1}`);\r\n  if (rightNeighbour !== undefined) neighbours.push(rightNeighbour);\r\n\r\n  const bottomNeighbour = heap.getNodeAt(`${node.row + 1}:${node.col}`);\r\n  if (bottomNeighbour !== undefined) neighbours.push(bottomNeighbour);\r\n\r\n  const leftNeighbour = heap.getNodeAt(`${node.row}:${node.col - 1}`);\r\n  if (leftNeighbour !== undefined) neighbours.push(leftNeighbour);\r\n\r\n  //   return neighbours.filter(\r\n  //     (neighbour) => neighbour.nodeState === NodeStates.UNVISITED\r\n  //   );\r\n\r\n  return neighbours.filter((neighbour) => neighbour.closed !== true);\r\n}\r\n\r\nexport function getShortestPath(endNode) {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    currentNode.nodeState = NodeStates.SHORTESTPATH;\r\n    shortestPath.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return shortestPath;\r\n}","import React, { Component } from \"react\";\r\nimport \"./path-finding-visualizer.css\";\r\nimport Grid from \"./grid\";\r\nimport NodeStates from \"./node-states\";\r\nimport {\r\n  createGrid,\r\n  replaceGrid,\r\n  clearVisitedNodes,\r\n  clearWallNodes,\r\n} from \"./grid-utilities\";\r\nimport { Help } from \"./help\";\r\nimport { executeBinaryTree } from '../algorithms/binary-tree';\r\nimport { executeRandom } from '../algorithms/random';\r\nimport { executeAStar, getShortestPath } from \"../algorithms/a-star\";\r\nimport { executeDijkstra } from \"../algorithms/dijkstra\";\r\nimport Dropdown from \"react-bootstrap/Dropdown\";\r\nimport DropdownButton from \"react-bootstrap/Dropdownbutton\";\r\n\r\nexport default class PathFindindVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      isHelpVisible: false,\r\n      selectedAlgo: executeDijkstra,\r\n      selectedAlgoName: \"Dijkstra\",\r\n      selectedMazeAlgo: executeBinaryTree,\r\n      selectedMazeAlgoName: \"Binary Tree\",\r\n      width: 0,\r\n      height: 0,\r\n      isVisualizing: false,\r\n      startNodeIndex: { row: 10, col: 5 },\r\n      endNodeIndex: { row: 10, col: 30 },\r\n      grid: [],\r\n    };\r\n\r\n    this.visitedAnimationTimeout = []\r\n    this.shortestPathTimeout = [];\r\n    this.isMaze = false;\r\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.updateArrayLength();\r\n    window.addEventListener(\"resize\", this.updateWindowDimensions);\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateWindowDimensions);\r\n  }\r\n\r\n  updateWindowDimensions() {\r\n    this.updateArrayLength();\r\n    this.reset();\r\n\r\n    if (this.state.startNodeIndex.row < 0 ||\r\n      this.state.startNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.startNodeIndex.col < 0 ||\r\n      this.state.startNodeIndex.col > this.state.grid[0].length - 1 ||\r\n      this.state.endNodeIndex.row < 0 ||\r\n      this.state.endNodeIndex.row > this.state.grid.length - 1 ||\r\n      this.state.endNodeIndex.col < 0 ||\r\n      this.state.endNodeIndex.col > this.state.grid[0].length - 1) {\r\n      this.setState({\r\n        startNodeIndex: { row: Math.floor(0), col: Math.floor(0) },\r\n        endNodeIndex: { row: Math.floor(this.rowCount - 1), col: Math.floor(this.colCount - 1) },\r\n      })\r\n    }\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n    this.setState({\r\n      grid: newGrid,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  }\r\n\r\n  updateArrayLength() {\r\n    this.nodeSize = 24;\r\n    this.rowCount = Math.floor(\r\n      (window.innerHeight - window.innerHeight / 5) / this.nodeSize\r\n    );\r\n    this.colCount = Math.floor(\r\n      (window.innerWidth - window.innerWidth / 18) / this.nodeSize\r\n    );\r\n\r\n    if (this.colCount % 2 === 0)\r\n      this.colCount -= 1;\r\n\r\n    if (this.rowCount % 2 === 0)\r\n      this.rowCount -= 1;\r\n\r\n    let root = document.documentElement;\r\n    root.style.setProperty(\"--nodeSize\", this.nodeSize + \"px\");\r\n  }\r\n\r\n  reset() {\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    Array.from(this.shortestPathTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    });\r\n    Array.from(this.visitedAnimationTimeout).forEach(element => {\r\n      clearTimeout(element);\r\n    })\r\n\r\n    this.isMaze = false;\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(this.state.grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    this.setState({ isVisualizing: false });\r\n  }\r\n\r\n  executePathfinding() {\r\n    if (this.state.isVisualizing) return;\r\n\r\n    const grid = this.state.grid;\r\n    const newGrid = replaceGrid(grid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const visitedNodesInOrder = this.state.selectedAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    const shortestPathNodes = getShortestPath(\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.visualize(visitedNodesInOrder, shortestPathNodes);\r\n  }\r\n\r\n  // Visualize visited nodes and shortest path (by calling visualizeShortestPath) on\r\n  visualize = (visitedNodesInOrder, shortestPath) => {\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (visitedNodesInOrder.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    for (let i = 1; i < visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        this.shortestPathTimeout.push(setTimeout(() => {\r\n          this.visualizeShortestPath(shortestPath);\r\n        }, 5 * i))\r\n      }\r\n\r\n      const row = visitedNodesInOrder[i].row;\r\n      const col = visitedNodesInOrder[i].col;\r\n\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      this.visitedAnimationTimeout.push(setTimeout(() => {\r\n        visitedNodesInOrder[i].nodeState = NodeStates.VISITED;\r\n        node.className = \"VisitedNode\";\r\n      }, 5 * i))\r\n    }\r\n  }\r\n\r\n  // Visualize shortestPath from array recieved in params\r\n  visualizeShortestPath(shortestPath) {\r\n    const grid = this.state.grid;\r\n    this.setState({ isVisualizing: true });\r\n\r\n    if (shortestPath.length === 1) {\r\n      this.setState({ isVisualizing: false });\r\n      return;\r\n    }\r\n\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const row = shortestPath[i].row;\r\n      const col = shortestPath[i].col;\r\n      grid[row][col] = shortestPath[i];\r\n      const node = document.getElementById(`${row}:${col}`);\r\n\r\n      this.shortestPathTimeout.push(setTimeout(() => {\r\n        if (node !== null) {\r\n          shortestPath[i].nodeState = NodeStates.SHORTESTPATH;\r\n          node.className = \"ShortestPathNode\";\r\n        }\r\n      }, 40 * i))\r\n      toWaitBeforeEnded += 40;\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n  }\r\n\r\n  visualizeMaze() {\r\n    if (this.state.isVisualizing) return;\r\n\r\n    const newGrid = createGrid(\r\n      this.rowCount,\r\n      this.colCount,\r\n      this.state.startNodeIndex,\r\n      this.state.endNodeIndex\r\n    );\r\n\r\n    this.setState({ grid: newGrid });\r\n    clearVisitedNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n    clearWallNodes(newGrid, this.state.startNodeIndex, this.state.endNodeIndex);\r\n\r\n    const maze = this.state.selectedMazeAlgo(\r\n      newGrid,\r\n      newGrid[this.state.startNodeIndex.row][this.state.startNodeIndex.col],\r\n      newGrid[this.state.endNodeIndex.row][this.state.endNodeIndex.col]\r\n    );\r\n\r\n    this.setState({ isVisualizing: true });\r\n    let toWaitBeforeEnded = 0;\r\n\r\n    for (let i = 1; i < maze.length; i++) {\r\n      const row = maze[i].row;\r\n      const col = maze[i].col;\r\n      const node = document.getElementById(`${row}:${col}`);\r\n      if (this.isMaze) {\r\n        maze[i].nodeState = NodeStates.WALL;\r\n        node.className = \"WallNode\";\r\n      } else {\r\n        this.visitedAnimationTimeout.push(setTimeout(() => {\r\n          maze[i].nodeState = NodeStates.WALL;\r\n          node.className = \"WallNode\";\r\n        }, 3 * i))\r\n        toWaitBeforeEnded += 3;\r\n      }\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this.setState({ isVisualizing: false });\r\n    }, toWaitBeforeEnded)\r\n\r\n    this.isMaze = true;\r\n  }\r\n\r\n  updateGrid = (newGrid) => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  updateStartEndIndex = (startNode, endNode) => {\r\n    this.setState({ startNodeIndex: startNode })\r\n    this.setState({ endNodeIndex: endNode });\r\n  };\r\n\r\n  selectAlgorithm = (selectedAlgo) => {\r\n    if (selectedAlgo === \"Dijkstra\") this.setState({ selectedAlgo: executeDijkstra, selectedAlgoName: \"Dijkstra\" });\r\n    if (selectedAlgo === \"A*\") this.setState({ selectedAlgo: executeAStar, selectedAlgoName: \"A*\" });\r\n    if (selectedAlgo === \"BinaryTree\") this.setState({ selectedMazeAlgo: executeBinaryTree, selectedMazeAlgoName: \"Binary Tree\" })\r\n    if (selectedAlgo === \"Random\") this.setState({ selectedMazeAlgo: executeRandom, selectedMazeAlgoName: \"Random\" })\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div style={{ height: \"100vh\" }} className=\"PathFindingVisualizer\">\r\n        <div className=\"Header\">\r\n          <div className=\"SubHeader\">\r\n            <h1 className=\"TitleText\">Pathfinding Visualizer</h1>\r\n          </div>\r\n\r\n          <div className=\"SubHeader\">\r\n            <DropdownButton id=\"DropDown\" title=\"Pathfinding Algorithm \">\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('Dijkstra')}>Dijkstra's Algorithm</Dropdown.Item>\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm('A*')} as=\"button\">A* Algorithm</Dropdown.Item>\r\n            </DropdownButton>\r\n\r\n            <button className=\"MainButton\" onClick={() => this.executePathfinding()}>Visualize {this.state.selectedAlgoName}</button>\r\n\r\n            <DropdownButton id=\"DropDown\" title=\"Maze Algorithm \">\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"BinaryTree\")} as=\"button\">Binary Tree</Dropdown.Item>\r\n              <Dropdown.Item id=\"MenuItem\" onClick={() => this.selectAlgorithm(\"Random\")} as=\"button\">Random</Dropdown.Item>\r\n            </DropdownButton>\r\n\r\n            <button className=\"MainButton\" onClick={() => this.visualizeMaze()}>{this.state.selectedMazeAlgoName} Maze</button>\r\n          </div>\r\n\r\n\r\n          <div className=\"SubHeader\">\r\n            <button className=\"SimpleTextButton\" onClick={() => this.reset()}>Reset</button>\r\n            <button className=\"SimpleTextButton\" onClick={() => this.setState({ isHelpVisible: !this.state.isHelpVisible })}>Help</button>\r\n          </div>\r\n        </div>\r\n\r\n        <Help isVisible={this.state.isHelpVisible}></Help>\r\n\r\n        <Grid\r\n          updateGrid={this.updateGrid}\r\n          updateStartEndIndex={this.updateStartEndIndex}\r\n          gridData={this.state.grid}\r\n          startNodeIndex={this.state.startNodeIndex}\r\n          endNodeIndex={this.state.endNodeIndex}\r\n          isVisualizing={(this.state.isVisualizing)}\r\n        />\r\n      </div >\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathFindingVisualizer from './path-finding-visualizer/path-finding-visualizer'\r\n\r\nfunction App() {\r\n  return (\r\n      <PathFindingVisualizer></PathFindingVisualizer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}